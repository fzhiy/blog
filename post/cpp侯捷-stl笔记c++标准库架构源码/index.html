<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>[C&#43;&#43;侯捷视频课笔记]C&#43;&#43;标准库——架构&amp;源码 - fzhiy&#39;s blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="fzhiy" /><meta name="description" content="[CPP侯捷视频课笔记]C&#43;&#43;标准库——架构&amp;amp;源码 [TOC] 源码之前 了无秘密 —— 侯捷 第一讲 架构 基础：C&#43;&#43;基本语法（包括如何正确使用模板，t" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.88.1 with theme even" />


<link rel="canonical" href="https://blog.fzhiy.net/post/cpp%E4%BE%AF%E6%8D%B7-stl%E7%AC%94%E8%AE%B0c&#43;&#43;%E6%A0%87%E5%87%86%E5%BA%93%E6%9E%B6%E6%9E%84%E6%BA%90%E7%A0%81/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="[C&#43;&#43;侯捷视频课笔记]C&#43;&#43;标准库——架构&amp;源码" />
<meta property="og:description" content="[CPP侯捷视频课笔记]C&#43;&#43;标准库——架构&amp;源码 [TOC] 源码之前 了无秘密 —— 侯捷 第一讲 架构 基础：C&#43;&#43;基本语法（包括如何正确使用模板，t" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.fzhiy.net/post/cpp%E4%BE%AF%E6%8D%B7-stl%E7%AC%94%E8%AE%B0c&#43;&#43;%E6%A0%87%E5%87%86%E5%BA%93%E6%9E%B6%E6%9E%84%E6%BA%90%E7%A0%81/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-03-05T09:21:56+08:00" />
<meta property="article:modified_time" content="2022-03-05T09:21:56+08:00" />

<meta itemprop="name" content="[C&#43;&#43;侯捷视频课笔记]C&#43;&#43;标准库——架构&amp;源码">
<meta itemprop="description" content="[CPP侯捷视频课笔记]C&#43;&#43;标准库——架构&amp;源码 [TOC] 源码之前 了无秘密 —— 侯捷 第一讲 架构 基础：C&#43;&#43;基本语法（包括如何正确使用模板，t"><meta itemprop="datePublished" content="2022-03-05T09:21:56+08:00" />
<meta itemprop="dateModified" content="2022-03-05T09:21:56+08:00" />
<meta itemprop="wordCount" content="9908">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="[C&#43;&#43;侯捷视频课笔记]C&#43;&#43;标准库——架构&amp;源码"/>
<meta name="twitter:description" content="[CPP侯捷视频课笔记]C&#43;&#43;标准库——架构&amp;源码 [TOC] 源码之前 了无秘密 —— 侯捷 第一讲 架构 基础：C&#43;&#43;基本语法（包括如何正确使用模板，t"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">fzhiy&#39;s blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="https://fzhiy.net">
        <li class="mobile-menu-item">fzhiy的空间</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">fzhiy&#39;s blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="https://fzhiy.net">fzhiy的空间</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">[C&#43;&#43;侯捷视频课笔记]C&#43;&#43;标准库——架构&amp;源码</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-03-05 </span>
        
          <span class="more-meta"> 约 9908 字 </span>
          <span class="more-meta"> 预计阅读 20 分钟 </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次阅读 </span>
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#cpp侯捷视频课笔记c标准库架构源码">[CPP侯捷视频课笔记]C++标准库——架构&amp;源码</a>
      <ul>
        <li><a href="#第一讲-架构">第一讲 架构</a>
          <ul>
            <li><a href="#参考资料">参考资料</a></li>
            <li><a href="#stl-六大部件">STL 六大部件</a></li>
          </ul>
        </li>
        <li><a href="#第二讲-源码主要是容器">第二讲 源码（主要是容器）</a>
          <ul>
            <li><a href="#oopobject-oriented-programmingvs-gpgeneric-programming">OOP（Object-Oriented programming）vs. GP（Generic Programming）</a></li>
            <li><a href="#技术基础-操作符重载-与-模板特化全特化偏特化">技术基础 操作符重载 与 模板（特化、全特化、偏特化）</a></li>
            <li><a href="#allocators分配器">allocators分配器</a></li>
            <li><a href="#容器结构与分类">容器，结构与分类</a></li>
            <li><a href="#迭代器的设计规则和iterator-traits的作用与设计">迭代器的设计规则和Iterator Traits的作用与设计</a></li>
            <li><a href="#容器vector">容器vector</a></li>
            <li><a href="#容器array">容器array</a></li>
            <li><a href="#容器forward_list">容器forward_list</a></li>
            <li><a href="#容器deque">容器deque</a></li>
            <li><a href="#容器queue">容器queue</a></li>
            <li><a href="#容器stack">容器stack</a></li>
            <li><a href="#queue和stack-关于其iterator和底层结构">queue和stack 关于其iterator和底层结构</a></li>
            <li><a href="#关联式容器容器rb_tree">[关联式容器]容器rb_tree</a></li>
            <li><a href="#容器setmultiset">容器set，multiset</a></li>
            <li><a href="#容器map-multimap">容器map, multimap</a></li>
            <li><a href="#容器hashtable">容器hashtable</a></li>
            <li><a href="#容器unordered_set-unordered_multiset-unordered_map-unordered_multimap">容器unordered_set, unordered_multiset, unordered_map, unordered_multimap</a></li>
          </ul>
        </li>
        <li><a href="#第三讲-体系结构与内核分析">第三讲 体系结构与内核分析</a>
          <ul>
            <li><a href="#迭代器的分类category">迭代器的分类（category）</a></li>
            <li><a href="#iterator_category对算法的影响">iterator_category对算法的影响</a></li>
            <li><a href="#算法源代码剖析11个例子">算法源代码剖析（11个例子）</a></li>
            <li><a href="#仿函数functors">仿函数functors</a></li>
            <li><a href="#适配器adapters">适配器Adapters</a></li>
          </ul>
        </li>
        <li><a href="#第四讲-体系结构与内核分析">第四讲 体系结构与内核分析</a>
          <ul>
            <li><a href="#一个万用的hash-function">一个万用的Hash Function</a></li>
            <li><a href="#tuple用例">tuple用例</a></li>
            <li><a href="#type-traits">type traits</a></li>
            <li><a href="#cout">cout</a></li>
            <li><a href="#moveable元素对各种容器速度效能的影响">moveable元素对各种容器速度效能的影响</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#参考资料-1">参考资料</a></li>
  </ul>
</nav>
  </div>
</div>
  <div class="post-outdated">
    <div class="warn">
      <p>【注意】最后更新于 <span class="timeago" datetime="2022-03-05T09:21:56" title="March 5, 2022">March 5, 2022</span>，文中内容可能已过时，请谨慎使用。</p>
    </div>
  </div>
    <div class="post-content">
      <h1 id="cpp侯捷视频课笔记c标准库架构源码">[CPP侯捷视频课笔记]C++标准库——架构&amp;源码</h1>
<p>[TOC]</p>
<blockquote>
<p><strong>源码之前 了无秘密</strong> —— 侯捷</p>
</blockquote>
<h2 id="第一讲-架构">第一讲 架构</h2>
<p>基础：C++基本语法（包括如何正确使用<strong>模板，templates</strong>）</p>
<p>目标：</p>
<ol>
<li>使用C++标准库</li>
<li>认识C++标准库（胸中自有丘壑）</li>
<li><strong>良好</strong>使用C++标准库</li>
<li>扩充C++标准库</li>
</ol>
<h3 id="参考资料">参考资料</h3>
<ul>
<li><a href="https://cplusplus.com/">https://cplusplus.com/</a></li>
<li><a href="https://en.cppreference.com/">https://en.cppreference.com/</a></li>
<li><a href="https://gcc.gnu.org/">https://gcc.gnu.org/</a></li>
<li>《The C++ Standard Library》 第二版</li>
<li>STL源码剖析，2002年 侯捷，GNU2.91（旧版）</li>
</ul>
<h3 id="stl-六大部件">STL 六大部件</h3>
<p><img src="https://img.fzhiy.net/img/image-20210617122354355.png" alt="image-20210617122354355"></p>
<p>container通过allocator取得数据存储空间，algorithm通过iterator存取container内容，functor协助algorithm完成不同策略变化，adapter可以修饰或套接functor。</p>
<ul>
<li>容器(containers):vector.list.deque,set,map等数据存放的类。</li>
<li>算法(algorithms):各种排序算法;sort、search、copy、erase..等</li>
<li>迭代器(iterators)：扮演容器与算法之间的胶合剂，即泛型指针</li>
<li>功能函数(functors)：行为类似函数，可以视为算法的某种策略</li>
<li>适配器(adapters)：一种用来修饰容器(containers)或仿函数(functors)或迭代器(iterators)借口的东西</li>
<li>分配器(allocators):负责空间配置与管理</li>
</ul>
<p>C++ 11开始</p>
<ul>
<li>range-based for statement</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">for</span> <span class="p">(</span><span class="nl">decl</span> <span class="p">:</span> <span class="n">coll</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">statement</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>auto 关键字</li>
</ul>
<h4 id="容器--分类">容器 —— 分类</h4>
<ul>
<li>
<p>Sequence Containers</p>
<ul>
<li>
<p>Array <img src="https://img.fzhiy.net/img/image-20210723110741841.png" alt="image-20210723110741841"></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="n">array</span><span class="o">&lt;</span><span class="kt">long</span><span class="p">,</span> <span class="n">ASIZE</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">;</span>  <span class="c1">// 大小为ASIZE，类型为long的数组a 
</span><span class="c1"></span><span class="n">qsort</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">ASIZE</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">),</span> <span class="n">compareLongs</span><span class="p">);</span>   <span class="c1">// cstdlib 库包含qsort，bsearch
</span><span class="c1"></span><span class="kt">long</span><span class="o">*</span> <span class="n">Item</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="o">*</span><span class="p">)</span><span class="n">bsearch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">target</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">data</span><span class="p">()),</span> <span class="n">ASIZE</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">),</span> <span class="n">compareLongs</span><span class="p">);</span> <span class="c1">//二分查找（&amp;target传引用），bsearch()返回的是target对应位置的指针
</span><span class="c1"></span><span class="n">array</span><span class="p">.</span><span class="n">data</span><span class="p">()</span> <span class="c1">//获得指向底层数组的指针
</span><span class="c1"></span>
<span class="kt">int</span> <span class="n">compareLongs</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span> <span class="o">*</span><span class="p">(</span><span class="kt">long</span><span class="o">*</span><span class="p">)</span><span class="n">a</span> <span class="o">-</span> <span class="o">*</span><span class="p">(</span><span class="kt">long</span><span class="o">*</span><span class="p">)</span><span class="n">b</span> <span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">compareStrings</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span> <span class="o">*</span><span class="p">(</span><span class="n">string</span><span class="o">*</span><span class="p">)</span><span class="n">a</span> <span class="o">&gt;</span> <span class="o">*</span><span class="p">(</span><span class="n">string</span><span class="o">*</span><span class="p">)</span><span class="n">b</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="o">*</span><span class="p">(</span><span class="n">string</span><span class="o">*</span><span class="p">)</span><span class="n">a</span> <span class="o">&lt;</span> <span class="o">*</span><span class="p">(</span><span class="n">string</span><span class="o">*</span><span class="p">)</span><span class="n">b</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> 
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Vector<img src="https://img.fzhiy.net/img/image-20210723110704793.png" alt="image-20210723110704793"> vector向后扩展是 <strong>两倍扩展</strong>的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt; // abort()</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt; 	// sprintf()</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt; // sort()</span><span class="cp">
</span><span class="cp"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="n">c</span><span class="p">;</span>
<span class="n">vector</span><span class="p">.</span><span class="n">size</span><span class="p">()</span>     <span class="c1">// vector当前实际占用大小
</span><span class="c1"></span><span class="n">vector</span><span class="p">.</span><span class="n">max_size</span><span class="p">()</span> <span class="c1">// 返回可容纳的最大元素数，此值通常反映容器大小上的理论极限，至多为 std::numeric_limits&lt;difference_type&gt;::max() 。运行时，可用 RAM 总量可能会限制容器大小到小于 max_size() 的值。
</span><span class="c1"></span><span class="n">vector</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span> <span class="c1">// 返回当前存储空间能够容纳的元素数，指在发生 realloc 前能允许的最大元素数，即预分配的内存空间。
</span><span class="c1"></span><span class="n">sort</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
<span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="n">rand</span><span class="p">());</span><span class="c1">//按照%d格式将rand()整数格式化为字符串，并将字符串复制到buf中，10为要写入的字符的最大数目，超过 10 会被截断。
</span><span class="c1"></span><span class="k">auto</span> <span class="n">pItem</span> <span class="o">=</span> <span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">target</span><span class="p">);</span> <span class="c1">// :: 表示 模板函数find()是全局函数，前序查找
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>List <img src="https://img.fzhiy.net/img/image-20210723112343104.png" alt="image-20210723112343104"></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">list</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="n">c</span><span class="p">;</span>
<span class="n">c</span><span class="p">.</span><span class="n">sort</span><span class="p">();</span> <span class="c1">// 容器list自带的sort（优先使用）
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Forward-List <img src="https://img.fzhiy.net/img/image-20210723113625765.png" alt="image-20210723113625765"></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="n">forward_list</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="n">c</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>slist (非标准库内的) 在gnu中的，与forward_list都相同。 __gnu_cxx::slist<string>c;</p>
</li>
<li>
<p>deque<img src="https://img.fzhiy.net/img/image-20210723114752744.png" alt="image-20210723114752744"> deque<string>c;</p>
<p><img src="https://img.fzhiy.net/img/image-20210723114924743.png" alt="image-20210723114924743"></p>
<p>每个buffer（8个bit）连续，两边扩展。</p>
</li>
</ul>
</li>
<li>
<p>Associative Containers</p>
<ul>
<li>
<p>Set / Multiset</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">multiset</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="n">c</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">pItem</span> <span class="o">=</span> <span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">target</span><span class="p">);</span> 
<span class="k">auto</span> <span class="n">pItem</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">target</span><span class="p">);</span> 						<span class="c1">//比::find()快很多
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Map / Multimap</p>
</li>
</ul>
</li>
<li>
<p>Unordered Containers （不定序容器，也是关系容器的一种）</p>
<ul>
<li>
<p>Unordered Set / Multiset</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="n">c</span><span class="p">;</span>
<span class="n">c</span><span class="p">.</span><span class="n">bucket_count</span><span class="p">();</span>
<span class="n">c</span><span class="p">.</span><span class="n">load_factor</span><span class="p">();</span>
<span class="n">c</span><span class="p">.</span><span class="n">max_load_factor</span><span class="p">();</span>
<span class="n">c</span><span class="p">.</span><span class="n">max_bucket_count</span><span class="p">();</span>
<span class="c1">// 与multiset有相同用法 c.find()，比::find()快很多【unordered_set、set 的用法与其相同】
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Unordered Map / Multimap</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">unordered_multimap</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="n">c</span><span class="p">;</span>
<span class="n">c</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">long</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">buf</span><span class="p">));</span> <span class="c1">// multimap不可使用[] 进行insertion
</span><span class="c1"></span><span class="k">auto</span> <span class="n">pItem</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">target</span><span class="p">);</span> <span class="c1">// long target = get_a_target_long(); 对应的value为(*pItem).second
</span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ul>
<p><img src="https://img.fzhiy.net/img/image-20210617143635326.png" alt="image-20210617143635326"></p>
<blockquote>
<p>红色圈起的部分即为 C++11新增的。</p>
</blockquote>
<p><img src="https://img.fzhiy.net/img/image-20210723164034517.png" alt="image-20210723164034517"></p>
<h2 id="第二讲-源码主要是容器">第二讲 源码（主要是容器）</h2>
<h3 id="oopobject-oriented-programmingvs-gpgeneric-programming">OOP（Object-Oriented programming）vs. GP（Generic Programming）</h3>
<ul>
<li>
<p>OOP企图将datas和methods关联在一起</p>
<p>为什么list不能使用::sort()排序？  <strong>first + (last - first) /2  <u>只有RandomAccessIterator才能如此操作</u></strong></p>
<p><img src="https://img.fzhiy.net/img/image-20210723175412006.png" alt="image-20210723175412006"></p>
</li>
<li>
<p>GP欲将datas和methods分开来  <u>左边是数据，右边是全局的函数</u></p>
<p><img src="https://img.fzhiy.net/img/image-20210723175549120.png" alt="image-20210723175549120"></p>
<p>采用GP：</p>
<ul>
<li>Containers和Algorithms团队可各自闭门造车，其间以Iterators连通即可</li>
<li>Algorithms通过Iterators确定操作范围，并通过Iterators取用Container元素</li>
</ul>
<p><img src="https://img.fzhiy.net/img/image-20210723180644482.png" alt="image-20210723180644482"></p>
<p><strong>所有algorithms，其内最终<u>涉及元素本身</u>的操作 无非就是<u>比大小</u>。</strong></p>
</li>
</ul>
<h3 id="技术基础-操作符重载-与-模板特化全特化偏特化">技术基础 操作符重载 与 模板（特化、全特化、偏特化）</h3>
<blockquote>
<p>《C++ Template》第二版</p>
</blockquote>
<p>类模板：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span><span class="k">class</span> <span class="nc">complex</span> <span class="p">{</span><span class="k">public</span><span class="o">:</span>     <span class="n">complex</span> <span class="p">(</span><span class="n">T</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">T</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">re</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="n">im</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{}</span>        <span class="n">complex</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">+=</span> <span class="p">(</span><span class="k">const</span> <span class="n">complex</span><span class="o">&amp;</span><span class="p">);</span>    <span class="n">T</span> <span class="nf">real</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">re</span><span class="p">;}</span>    <span class="n">T</span> <span class="nf">imag</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">im</span><span class="p">;}</span><span class="k">private</span><span class="o">:</span>    <span class="n">T</span> <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">;</span>        <span class="k">friend</span> <span class="n">complex</span><span class="o">&amp;</span> <span class="n">_doapl</span> <span class="p">(</span><span class="n">complex</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="n">complex</span><span class="o">&amp;</span><span class="p">);};{</span>    <span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">c1</span><span class="p">(</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">);</span>    <span class="n">complex</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">c2</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>    <span class="p">....}</span>
</code></pre></td></tr></table>
</div>
</div><p>函数模板：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span><span class="kr">inline</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">min</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>	<span class="c1">// 编译器对函数模板进行 `参数推导`    return b &lt; a ? b : a;}
</span></code></pre></td></tr></table>
</div>
</div><p>成员模板：</p>
<h4 id="特化">特化</h4>
<p><strong>出现<code>template&lt;&gt; </code>则是特化</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203031705822.png" alt="image-20220303170508356"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203031707602.png" alt="image-20220303170720262"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203031708861.png" alt="image-20220303170814639"></p>
<h4 id="偏特化">偏特化</h4>
<p><strong>分类：</strong></p>
<ol>
<li><strong>模板中有 多个参数，绑定部分参数</strong>；（<strong>个数的偏特化</strong>）</li>
<li><strong>范围的偏特化</strong></li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203031710049.png" alt="image-20220303171042920"></p>
<h3 id="allocators分配器">allocators分配器</h3>
<p><strong>malloc()的额外开销</strong> 在于：下图中 <strong>上下两个红色的部分（习惯叫 cookie，记录着这个分配空间的大小）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203031856079.png" alt="image-20220303185640506"></p>
<p>VC6的标准库，其中allocator的实现中 <strong>operator new()调用malloc()</strong>， operator deallocate</p>
<p><u>allocator接口</u>的难用之处在于 <strong>要指出当时分配的内存大小即 size_type.</strong> 容器用它则没有这个问题。（<strong>为什么？ 封装好了底层自动完成吗？</strong>）</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203031844717.png" alt="image-20220303184446313"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203031846133.png" alt="image-20220303184650956"></p>
<p>BC5标准库的 allocator实现：</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203031849514.png" alt="image-20220303184902098"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203031851135.png" alt="image-20220303185144443"></p>
<p><strong>VC, BC, G2.9的 allocator都是以 ::operator new和::operator delete完成allocate() 和 deallocate()，没有任何特殊设计。</strong></p>
<p>G 2.9 STL对allocator的使用：</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203031855577.png" alt="image-20220303185525995"></p>
<p>G 2.9中<strong>alloc</strong>分配器的实现：（减少了前面allocator的额外开销(cookie)）一次分配很大的一块内存，然后根据申请的空间划分成小块的内存，用单向链表连接起来。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203031855686.png" alt="image-20220303185558473"></p>
<p>但是G4.9版本中没有使用alloc分配器。 而是std::allocator<img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203031903491.png" alt="image-20220303190356565"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203031904690.png" alt="image-20220303190424425"></p>
<p>G 4.9所附的标准库有很多 <strong>extention allocators</strong>，其中**__pool_alloc 就是G2.9的alloc**。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203031906534.png" alt="image-20220303190642170"></p>
<p>为什么默认使用的是 std::allocator 而不是更省空间的 __pool_alloc？ <strong>不知道。</strong></p>
<h3 id="容器结构与分类">容器，结构与分类</h3>
<p>下图中 以 <strong>缩排</strong>的形式表示 “基层与衍生层”的关系，这里的<strong>衍生 是 复合关系</strong>， 而不是继承。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203071928924.png" alt="image-20211213212056517"></p>
<h4 id="容器list">容器list</h4>
<p>每次为list申请分配空间的时候，会为<strong>每个节点多申请两个指针的空间</strong> 存储 prev 和 next。</p>
<blockquote>
<p>注意：__list_node中的 pointer类型是 <strong>void</strong>*</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203031916519.png" alt="image-20220303191641071"></p>
<p>除了vector和array以外的 所有容器中的 <strong>iterator</strong> <strong>必须是一个 class</strong> 才能是一个 智能指针。</p>
<p><strong>list的iterator</strong></p>
<p>iterator ++</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203031927927.png" alt="image-20220303192710656"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203031927358.png" alt="image-20220303192737214"></p>
<p>**整数类型 不能使用后加加 加两次 即 i++++是不允许的。**所以为了模拟int类型的操作，（<strong>后缀形式，后加加</strong>） operator++(int)的返回类型是<code> self</code>，但 （<strong>前缀形式，前加加</strong>）operator++() 的返回类型是<code>self &amp;</code>。<strong>后缀形式调用前缀形式来实现 加法（这样的方法在STL中经常使用）</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203031937532.png" alt="image-20220303193711364"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203031939446.png" alt="image-20220303193900503"></p>
<p>G4.9的模板参数只有一个了（<strong>容易理解</strong>）。node的成员的type更精确了，而不是void*.</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203031942839.png" alt="image-20220303194241602"></p>
<p>list的类之间的关系更加复杂了。（所以用<strong>G2.9版本作为讲解</strong>）</p>
<h3 id="迭代器的设计规则和iterator-traits的作用与设计">迭代器的设计规则和Iterator Traits的作用与设计</h3>
<p>Iterator Trait 是人为设计的一种<strong>萃取机（萃取特征）</strong>。</p>
<ul>
<li>
<p><code>iterator_category</code> 指的是 iterator的移动性质（++, &ndash;， += 3）。</p>
</li>
<li>
<p><code>value_type</code>指的是实际元素的类型。</p>
</li>
<li>
<p><code>difference_type</code> 指的 是 两个元素之间的距离对应的类型 。</p>
</li>
<li>
<p>另外两种（<strong>这两种在算法中从未使用过</strong>）分别是：<code>reference_type</code></p>
</li>
<li>
<p><code>pointer_type</code></p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203031948473.png" alt="image-20220303194836307"></p>
<p><strong>算法提问， 迭代器回答。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203031956433.png" alt="image-20220303195621193"></p>
<p>指针pointer 视作是一种退化的iterator，iterator是一种泛化的pointer。</p>
<h4 id="traits特性">Traits特性</h4>
<p><strong>Iterator Traits是一个萃取机。</strong> 用于**分离 <u>classs</u> iterators 和 <u>non-class</u> itertors  **</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203031956685.png" alt="image-20220303195646320"></p>
<p>（<strong>银弹</strong>）即 解决计算机问题的尚方宝剑：加一个中介层。（这里的中介层 就是 Iterator Traits）</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203032004162.png" alt="image-20220303200435147"></p>
<p>上图中 第三个 iterator_traits 里的声明是 typedef T value_type，而不是const T的原因是：<strong>若声明为const T，那么无法被赋值 就没有用了。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203032010587.png" alt="image-20220303201028194"></p>
<h4 id="各种各样的traits">各种各样的Traits</h4>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203032016212.png" alt="image-20220303201616790"></p>
<h3 id="容器vector">容器vector</h3>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203032017887.png" alt="image-20220303201750758"></p>
<p>sizeof(vector&lt;T&gt;) 的大小为 12（32位操作系统，在64位操作系统上。即为3个指针 start, finish, end_of_storage的大小）</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203032037228.png" alt="image-20220303203736142"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203032037818.png" alt="image-20220303203754788"></p>
<h4 id="vector的iterator">vector的iterator</h4>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203032041726.png" alt="image-20220303204122528"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203032044312.png" alt="image-20220303204435316"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203032046087.png" alt="image-20220303204646094"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203032048775.png" alt="image-20220303204849892"></p>
<h3 id="容器array">容器array</h3>
<blockquote>
<p>TR1：Technical Report 1. C++98与C++11之间的过渡版本（大概是2003年）。</p>
</blockquote>
<p>array 没有 ctor，也没有dtor。</p>
<p><strong>像array、vector连续空间的容器，可以 <u>直接用单纯的指针作为iterator。</u></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203032049202.png" alt="image-20220303204958134"></p>
<p>**typedef int T[100]; **</p>
<p><strong>T</strong> c;</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203032051306.png" alt="image-20220303205155360"></p>
<h3 id="容器forward_list">容器forward_list</h3>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203032101112.png" alt="image-20220303210117026"></p>
<h3 id="容器deque">容器deque</h3>
<blockquote>
<p>deque号称是连续的，<strong>实际上是分段连续</strong>的。</p>
</blockquote>
<p>可以双向扩充，每个buffer对应一个buffer。</p>
<p>deque是<strong>分段连续</strong>的，为了维持连续的表象，迭代器走到边界（<strong>first或者last</strong>）的时候需要有能力（<strong>利用node</strong>）跳到下一个元素对应的空间位置。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203032101333.png" alt="image-20220303210131160"></p>
<p><strong>map_size 是以<u>两倍的速度增长</u>的（就是一个vector）。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203032101102.png" alt="image-20220303210158039"></p>
<p><strong>sizeof(deque&lt;T&gt;) = 16 + 16 + 4 + 4 = 40（32位操作系统）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203032116395.png" alt="image-20220303211411111"></p>
<p>deque iteraotr里面有四个指针 即cur、first、last和node。因此<strong>sizeof(__deque_iterator&lt;T&gt;)的大小是16（32位操作系统）</strong>。</p>
<h4 id="dequetinsert">deque&lt;T&gt;::insert()</h4>
<p>逻辑：</p>
<ul>
<li>如果插入的位置在deque<strong>最前端</strong>，则直接push_front()；</li>
<li>如果插入的位置在deque <strong>最尾端</strong>，则直接push_back()；</li>
<li>否则 判断插入的位置是靠近 <strong>前半部分</strong> 还是 <strong>后半部分</strong>，然后移动相应部分的元素，最后插入元素。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203032122346.png" alt="image-20220303212223671"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203032122576.png" alt="image-20220303212243391"></p>
<h4 id="deque如何模拟连续空间">deque如何模拟连续空间</h4>
<p><strong>全是deque iterators的功能。</strong> 求size() 中的 finish <strong>-</strong> start 的减号经过<strong>重载的</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203032128980.png" alt="image-20220303212821984"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203032130210.png" alt="image-20220303213052092"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203032133699.png" alt="image-20220303213334651"></p>
<p><strong>+=</strong> （-= 通过调用 += 来实现的）</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203032139911.png" alt="image-20220303213902847"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203032141744.png" alt="image-20220303214135640"></p>
<h4 id="g49版本中的deque">G4.9版本中的deque</h4>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203032143345.png" alt="image-20220303214338131"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203032145079.png" alt="image-20220303214555811"></p>
<p>deque中的map 内存大小是 两倍增长的；而两端剩余未使用的内存空间会保持相等，也就是会通过移动map的元素到<strong>中段</strong>，以<strong>保证deque可以两端扩充</strong>。</p>
<h3 id="容器queue">容器queue</h3>
<p><strong>queue的内部使用了 deque。</strong>  （因为是将deque改装了，自己实际上没做什么事，所以有时称为“适配器”）</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203032148311.png" alt="image-20220303214843423"></p>
<h3 id="容器stack">容器stack</h3>
<p><strong>同queue一样，内部使用了deque。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203032151957.png" alt="image-20220303215123081"></p>
<h3 id="queue和stack-关于其iterator和底层结构">queue和stack 关于其iterator和底层结构</h3>
<p><strong>stack 和 queue都不允许遍历，也不提供iterator【编译错误</strong>】。</p>
<ul>
<li><strong>stack和queue都可以选择list或deque为底层结构。（但是deque作为底层结构比较快！）</strong></li>
<li><strong>stack可以选择vector作为底层结构</strong>，queue <strong>不可以</strong>选择vector作为底层结构（pop()会调用pop_front() 发生编译错误！）</li>
<li><strong>stack和queue都 <u>不可以</u>选择set或map作为底层结构。</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203032152232.png" alt="image-20220303215249985"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203032153793.png" alt="image-20220303215338742"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203032158977.png" alt="image-20220303215800847"></p>
<h3 id="关联式容器容器rb_tree">[关联式容器]容器rb_tree</h3>
<blockquote>
<p>前面讨论的list、vector、array、forward_list、deque、queue和stack都是<strong>序列式容器</strong>。 关联式容器查找非常快，类似一个小型数据库。</p>
</blockquote>
<p>rb_tree的两个底层结构：<strong>红黑树（高度平衡的二叉搜索树，有利于查找），哈希表</strong>。</p>
<p>rb_tree提供“遍历”操作 及 iterators。</p>
<p>我们<strong>不应</strong>使用rb_tree的iterators改变元素值（<strong>因为元素其有其最严谨排列规则</strong>）。 map允许 <u>元素的data</u>被改变，只有 <u>元素的key</u>才是不可被改变的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203032202618.png" alt="image-20220303220203244"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041313402.png" alt="image-20220304092217256"></p>
<p>key和data 组成 value。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041313772.png" alt="image-20220304092249424"></p>
<p>identity仿函数：实现获取自身元素。</p>
<h4 id="容器rb_tree用例">容器rb_tree用例</h4>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041313004.png" alt="image-20220304092314104"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203050940857.png" alt="image-20220304092326111"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041314328.png" alt="image-20220304092533802"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041314223.png" alt="image-20220304092555251"></p>
<h3 id="容器setmultiset">容器set，multiset</h3>
<ul>
<li>
<p>set和multiset以rb_tree为底层结构，因此 <strong>有 元素自动排序</strong>特性，排序的依据是key（key就是value）。</p>
</li>
<li>
<p>提供遍历操作及iterators，按 ++iter遍历 就能得到排序状态值。</p>
</li>
<li>
<p><strong>无法</strong>使用set/multiset的iterators（<strong>实际实现中的iterator是 const_iterator</strong>，见下图）改变元素值（因为key就是value）；</p>
</li>
<li>
<p>set和multiset的区别在于 multiset的key可以重复。</p>
<ul>
<li>set元素的key必须独一无二，其insert()用的是rb_tree的<strong>insert_unique</strong>()；</li>
<li>multiset元素的key可以重复，其insert()用的是rb_tree的<strong>insert_equal</strong>()。</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041314231.png" alt="image-20220304092642231"></p>
<p>set底层实现中的后两个模板参数有默认值 less&lt;Key&gt; 和 alloc。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041314551.png" alt="image-20220304093357549"></p>
<p>set的所有操作，都是让底层t操作，从这个意义上来看，set是个container adapter。</p>
<h4 id="容器set-in-vc6">容器set in VC6</h4>
<p>上面讲述的identity()是 GNUC特有的。VC6不提供identity()，set和map使用RB-tree的时候 则<strong>自己实现identity()即下图中的_Kfn</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041314925.png" alt="image-20220304094057492"></p>
<h4 id="使用容器multiset">使用容器multiset</h4>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041314180.png" alt="image-20220304094327370"></p>
<h3 id="容器map-multimap">容器map, multimap</h3>
<ul>
<li>
<p>map和multimap以rb_tree为底层结构，因此 <strong>有 元素自动排序</strong>特性，<u>与set/multiset不同的是，其key和data合成value，而不是（key就是value，value就是key）</u>。</p>
</li>
<li>
<p>提供遍历操作及iterators，按 ++iter遍历 就能得到排序状态值。</p>
</li>
<li>
<p><strong>无法</strong>使用map/multimap的iterators改变key，但是<strong>能改data</strong>。</p>
</li>
<li>
<p>map和multimap的区别在于 multimap的key可以重复。</p>
<ul>
<li>map元素的key必须独一无二，其insert()用的是rb_tree的<strong>insert_unique</strong>()；</li>
<li>multimap元素的key可以重复，其insert()用的是rb_tree的<strong>insert_equal</strong>()。</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041314779.png" alt="image-20220304094630924"></p>
<p>map的底层实现中后两个模板参数是默认的 即 less&lt;Key&gt;和alloc。 下图例子中key的类型是int，data的类型是string。</p>
<p>通过map的iterator可以修改data，不能修改key。下图实现中的iterator就是rb_tree的data。<strong>pair&lt;<u>const</u> Key, T&gt; value_type 中的Key是const类型，所以不能改变key。</strong></p>
<p>select1st() 是GNUC独有的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041314133.png" alt="image-20220304095354385"></p>
<h4 id="容器mapin-vc6">容器map，in VC6</h4>
<p>VC6通过**自己实现 _Kn（G2.9中的select1st()功能）**来使用RB-tree。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041314648.png" alt="image-20220304095601872"></p>
<h4 id="使用multimap">使用multimap</h4>
<blockquote>
<p>小技巧：每个测试用例包括在一个不同的namespace里。</p>
</blockquote>
<p>下图用例的 key是[0, value), 不会重复，虽然multimap允许key重复。</p>
<p><strong>multimap不可使用[] 做 insertion。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041314159.png" alt="image-20220304100243096"></p>
<p><strong>容器map独有的operator[]</strong></p>
<p>返回与key对应的value。如果<strong>key不存在</strong>，将<strong>创建</strong>一个具有默认值的key 并返回。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041314964.png" alt="image-20220304100609232"></p>
<h4 id="使用容器map">使用容器map</h4>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041314359.png" alt="image-20220304101337077"></p>
<p>红黑树：set和map的底层结构。</p>
<h3 id="容器hashtable">容器hashtable</h3>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041314047.png" alt="image-20220304101453611"></p>
<p>发生碰撞时，使用<u>链表来处理冲突</u>，称为链式哈希。</p>
<p><strong>bucket（大小一般是质数, 在GUNC是53）</strong>，如果一个链表的长度大于buckets vector的长度，那么<strong>一般将 bucket vector长度翻倍（最近的一个质数，如97）（经验）</strong>。 这样的操作称 <strong>rehash</strong>。<strong>时间消耗</strong>花费在重新计算位置并<strong>拷贝移动上</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041315565.png" alt="image-20220304101505190"></p>
<p>下图的HashFun用于获取哈希编号。 ExtractKey用于从pair中提取处key，EqualKey用于Key的判断是否相等。</p>
<p>三个对象hash、equals和get_key的内部没有元素，但其实际大小为1字节，所以总共3字节。buckets是一个vector，里面有三个指针，12个字节。size_type 4个字节。因此 sizeof() = 1 * 3 + 4 * 3 + 4  + <strong>1（对齐）</strong>= 20.</p>
<p>GNUC中链表是单向链表，VC6的实现是双向链表，确保能够进入下一个bucket。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041316913.png" alt="image-20220304101523997"></p>
<h4 id="使用hashtable">使用hashtable</h4>
<p>hashtable&lt;const char*, const char*, hash&lt;const char*&gt;, identity&lt;const char*&gt;, **eqstr**, alloc&gt; 中 为什么是eqstr， 而不能是strcp()，这是因为 **hashtable中要求其返回值是bool类型，而不能传回的是-1, 0, 1**，所以必须加一层外套。</p>
<p><strong>hashtable使用的关键：HashFun如何设计（即 将一个对象或字符串转换成一个编号）？</strong> —— 没有统一的计算方法，<strong>只要编号够乱，不发生碰撞即可。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041316956.png" alt="image-20220304101536566"></p>
<h4 id="hash-functionhash-code">hash-function，hash-code</h4>
<p>数值就作为编号。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041316881.png" alt="image-20220304101548054"></p>
<p>hash function的目的：希望根据元素值计算出一个 <strong>hash code</strong>（<strong>一个可以进行modulus运算的值</strong>），使得元素经hash code映射之后能够 【够乱】地被置于hashtable内。 <strong>越乱越不容易发生碰撞</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041317006.png" alt="image-20220304101558674"></p>
<h5 id="modules运算">modules运算</h5>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041317845.png" alt="image-20220304105503797"></p>
<p><strong>hash</strong>(key) % n中的hash是 <strong>class hashtable中的hashser hash</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041317964.png" alt="image-20220304105854315"></p>
<h4 id="hashtable用例">hashtable用例</h4>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041317534.png" alt="image-20220304110017861"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041317027.png" alt="image-20220304110127524"></p>
<h3 id="容器unordered_set-unordered_multiset-unordered_map-unordered_multimap">容器unordered_set, unordered_multiset, unordered_map, unordered_multimap</h3>
<blockquote>
<p>C++11开始改名为 unordered_set, unordered_multiset, unordered_map, unordered_multimap</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041317275.png" alt="image-20220304110308491"></p>
<h4 id="使用unordered_set">使用unordered_set</h4>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041317008.png" alt="image-20220304120245941"></p>
<h2 id="第三讲-体系结构与内核分析">第三讲 体系结构与内核分析</h2>
<p>C++标准库的算法 是什么？</p>
<p>从语言层面讲：</p>
<ul>
<li>容器Container是个class template；</li>
<li>算法Algorithm 是个<strong>function template</strong>；</li>
<li>迭代器Iterator是个class template；</li>
<li>仿函数Function是个class template；</li>
<li>适配器Adapter是个class template；</li>
<li>分配器Allocator是个class template。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041317467.png" alt="image-20220304120635893"></p>
<h3 id="迭代器的分类category">迭代器的分类（category）</h3>
<p>移动能力的分类：</p>
<ul>
<li><code>input_iterator_tag</code></li>
<li><code>output_iterator_tag</code></li>
<li><code>forward_iterator_tag</code>： forward_list</li>
<li><code>bidirectional_iterator_tag</code>：不能跳</li>
<li><code>random_access_iterator_tag</code> ：可以跳</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041317514.png" alt="image-20220304121450053"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041318728.png" alt="image-20220304121833735"></p>
<p>各种容器的iterators的iterator_category</p>
<ul>
<li>array   =&gt;  random_access_iterator</li>
<li>vector =&gt;  random_access_iterator</li>
<li>list       =&gt;  bidirectional_iterator</li>
<li>forward_list =&gt; forward_iterator</li>
<li>deque           =&gt; random_access_iterator</li>
</ul>
<p><strong>set, map, multiset, multimap都是以红黑树为底层结构</strong></p>
<ul>
<li>set        =&gt; bidirectional_iterator</li>
<li>map     =&gt; bidirectional_iterator</li>
<li>multiset    =&gt; bidirectional_iterator</li>
<li>multimap =&gt; bidirectional_iterator</li>
<li>unordered_set    =&gt; forward_iterator</li>
<li>unordered_map =&gt; forward_iterator</li>
<li>unordered_multiset    =&gt; forward_iterator</li>
<li>unordered_multimap =&gt; forward_iterator</li>
</ul>
<p>特殊的两个iterator</p>
<ul>
<li><strong>istream_iterator    =&gt; input_iterator</strong></li>
<li><strong>ostream_iterator   =&gt; output_iterator</strong></li>
</ul>
<h4 id="各种容器的iterators的iterator_category的typeid">各种容器的iterators的iterator_category的typeid</h4>
<p>可以将typeid()视作C++的一种操作符，获得一个对象， typeid().name()获得对象的名称。</p>
<p>返回值由实现所定义，实际输出取决于库的实现（但具体哪种iterator是相同的）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041318266.png" alt="image-20220304122917946"></p>
<p>虽然G2.9, G3.3, G4.9每个版本的具体实现不太相同，但是<strong>不影响接口的使用（接口一样）</strong>。比如 其模板参数都只需要传入一个参数，其他的都有默认值。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041318180.png" alt="image-20220304123344593"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041318328.png" alt="image-20220304123551353"></p>
<h3 id="iterator_category对算法的影响">iterator_category对算法的影响</h3>
<p>distance() 这个函数模板用于 求两个iterator直接的距离。</p>
<ul>
<li>如果是<strong>连续空间（random_access_iterator_tag表示）</strong>，则调用__distance(RandomAccessIterator first, RandomAccessIterator last, <strong>random_access_iterator_tag</strong>) 直接对两个iterator做减法；</li>
<li>如果是 <strong>非连续空间（input_iterator_tag表示）</strong>，则调用__distance(InputIterator first, InputIterator last, <strong>input_iterator_tag</strong>)，<strong>遍历iterator并计数返回</strong>。</li>
</ul>
<p>第一种的效率更高。</p>
<p>distance()的返回类型是 <strong>iterator_traits&lt;InputIterator&gt;::difference_type</strong>是考虑到了不同情况下返回类型可能不同。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041318215.png" alt="image-20220304124158224"></p>
<p>__advance()</p>
<ul>
<li>可以跳，则调用 __advance(RandomAccessIterator&amp; i, Distance n, <strong>random_access_iterator_tag</strong>)</li>
<li>双向，则调用__advance(BidirectionalIterator&amp; i, Distance n, <strong>bidirectional_iterator_tag</strong>)</li>
<li>否则 调用__advance(InputIterator&amp; i, Distance n, input_iterator_tag)。</li>
</ul>
<p>iterator_category()是一个辅助函数，功能与前面的iterator_traits&lt;InputIterator&gt;::iterator_category相同。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041312408.png" alt="image-20220304130057229"></p>
<h4 id="iterator_category和type-traits对算法的影响">iterator_category和type traits对算法的影响</h4>
<blockquote>
<p>Type Traits在第四讲。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041312825.png" alt="image-20220304131246326"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041328599.png" alt="image-20220304132804461"></p>
<p>destroy()的源代码：</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041329849.png" alt="image-20220304132937866"></p>
<p>output_iterator（比如 <strong>ostream_iterator</strong>）是 <strong>write-only</strong>（只可写的），无法像forward iterator那样可以 <strong>read</strong>，因此不能有类似（右侧）<u>*result != *first</u>的动作，因此<strong>设计出（左侧）的版本</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041330788.png" alt="image-20220304133038932"></p>
<h4 id="算法源码中对-iterator_category的暗示">算法源码中对 iterator_category的“暗示”</h4>
<p>模板参数类的命名<strong>提示 开发者需要传入的iterator需要满足该类型，否则后面代码可能会编译不通过</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041337397.png" alt="image-20220304133729807"></p>
<h3 id="算法源代码剖析11个例子">算法源代码剖析（11个例子）</h3>
<p>先前示例中出现的算法：</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041341920.png" alt="image-20220304134100105"></p>
<h4 id="1-算法accumulate">1. 算法accumulate</h4>
<p>接受三个参数，first和last迭代器，初始值init</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041341091.png" alt="image-20220304134153389"></p>
<h4 id="2-算法for_each">2. 算法for_each</h4>
<p>接受三个参数，first和last迭代器，函数f</p>
<blockquote>
<p>C++11开始</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">for</span><span class="p">(</span><span class="nl">decl</span> <span class="p">:</span> <span class="n">coll</span><span class="p">)</span> <span class="p">{</span>	<span class="n">statement</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041346216.png" alt="image-20220304134559579"></p>
<h4 id="3-算法replace-replace_if-replace_copy">3. 算法replace, replace_if, replace_copy</h4>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041349363.png" alt="image-20220304134955349"></p>
<h4 id="4-算法count-count_if">4. 算法count, count_if</h4>
<p>左边是全局函数，右边是容器的成员函数。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041351746.png" alt="image-20220304135156576"></p>
<h4 id="5-算法findfind_if">5. 算法find，find_if</h4>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041353927.png" alt="image-20220304135345776"></p>
<h4 id="6算法sort">6.算法sort</h4>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041354565.png" alt="image-20220304135401426"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041354177.png" alt="image-20220304135413041"></p>
<h4 id="6算法binary_search">6.算法binary_search</h4>
<p>必须先排序后再进行二分。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041404641.png" alt="image-20220304140448465"></p>
<h3 id="仿函数functors">仿函数functors</h3>
<p><strong>仿函数只为算法服务。 Algorithm(Iterator itr1, Iterator itr2, <u>Cmp</u> comp)里的Cmp即为仿函数类。</strong></p>
<ul>
<li>算术类</li>
<li>逻辑运算类</li>
<li>相对关系类</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041411439.png" alt="image-20220304141115909"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041416103.png" alt="image-20220304141600985"></p>
<p>算法sort()的Cmp可以是 函数myfunc，<strong>也可以是函数对象myobj</strong>。 传入的less&lt;int&gt;()和greater&lt;int&gt;()表示一个对象。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041418041.png" alt="image-20220304141809876"></p>
<h4 id="仿函数functors的可适配adaptable条件">仿函数functors的可适配（adaptable）条件</h4>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041422579.png" alt="image-20220304142219085"></p>
<p>less继承了binary_function中的三个typedef。</p>
<h3 id="适配器adapters">适配器Adapters</h3>
<p>想要A拥有B的功能，有两种方法：继承 或 复合（composition，拥有）。</p>
<p>Adapters中使用 <strong>复合</strong>的方法。 Functor Adapters内含了Functors，其他适配器类似。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041432225.png" alt="image-20220304143248121"></p>
<h4 id="容器适配器stackqueue">容器适配器stack，queue</h4>
<p>如下图：stack和queue都<strong>内含了一个deque</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041432607.png" alt="image-20220304143258642"></p>
<h4 id="函数适配器binder2nd">函数适配器binder2nd</h4>
<p>typedef <strong>typename</strong> Operation::second_argument_type arg2_type;</p>
<p><strong>编译过程中不知道Operation是什么</strong>， 使用<strong>typename</strong>保证Operation是一个类型，<strong>保证编译能通过</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041433164.png" alt="image-20220304143312106"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041433352.png" alt="image-20220304143322383"></p>
<p>下图中用左侧的 代替 右侧的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041433743.png" alt="image-20220304143334674"></p>
<h5 id="新型适配器bindsince-c11">新型适配器bind（Since C++11）</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;functional&gt; // std::bind</span><span class="cp">
</span></code></pre></td></tr></table>
</div>
</div><p>std::bind 可以绑定：</p>
<ol>
<li>functions</li>
<li>function objects</li>
<li>member functions, **_1（表示占位符）**必须是某个object地址；</li>
<li>data_members，_1必须是某个object地址</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041433055.png" alt="image-20220304143348035"></p>
<h4 id="迭代器适配器reverse_iterator">迭代器适配器reverse_iterator</h4>
<p>rend()对应的元素取begin()的前一个，rbegin()对应的元素取end()的前一个。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041434601.png" alt="image-20220304143359754"></p>
<h4 id="迭代器适配器inserter">迭代器适配器：inserter</h4>
<p>inserter在list中直接插入另一个list（可能插入位置后面的空间不够copy插入的，具体如下例：）</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041434718.png" alt="image-20220304143410760"></p>
<h4 id="x未知适配器">X(未知)适配器</h4>
<h5 id="ostream_iterator">ostream_iterator</h5>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041434084.png" alt="image-20220304143423208"></p>
<h5 id="istream_iterator">istream_iterator</h5>
<p>istream_iterator中的 数据成员in_stream使得 下面的例子能够实现 <strong>cin&raquo;value</strong>，然后进行乘法操作的功能。</p>
<p>当创建对象iit时（std::istream_iterator&lt;double&gt; iit(std::cin); ），立即调用了++*this，然后读入了数据value。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041434246.png" alt="image-20220304143435280"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041434289.png" alt="image-20220304143455593"></p>
<p><strong>使用一个东西，却不明白它的道理，不高明！</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041628867.png" alt="image-20220304162827374"></p>
<p>上图是使用模板 写错一行代码（但是报了一堆的错误）的示例。</p>
<h2 id="第四讲-体系结构与内核分析">第四讲 体系结构与内核分析</h2>
<blockquote>
<p><strong>勿在浮沙筑高台。</strong></p>
</blockquote>
<h3 id="一个万用的hash-function">一个万用的Hash Function</h3>
<p>左边的CustomerHash在unordered_set&lt;Customer, CustomerHash&gt; custset; 中被当作函数调用，调用的是CustomerHash类中的成员函数operator().</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041630892.png" alt="image-20220304163033532"></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// 辅助函数template &lt;typename... Types&gt; 	// typename... 接受任意个模板参数 （称为variadic templates 即 可变化的模板）inlinesize_t hash_val(const Types&amp;... args) {    size_t seed = 0;    hash_val(seed, args...);    return seed;}
</span></code></pre></td></tr></table>
</div>
</div><p>下图中1，2，3对应的hash_val()函数由于函数参数的不同，所以是不同的函数（重载的一种）。根据具体参数调用不同的函数。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041636030.png" alt="image-20220304163621029"></p>
<p>关于0x9e3779b9的来源：</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041705296.png" alt="image-20220304170535403"></p>
<h4 id="实际实现">实际实现</h4>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041706827.png" alt="image-20220304170655575"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041707496.png" alt="image-20220304170706636"></p>
<h4 id="以ustruct-hash偏特化u形式实现hash-function">以<u>struct hash偏特化</u>形式实现Hash Function</h4>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041820114.png" alt="image-20220304182025366"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041821191.png" alt="image-20220304182134955"></p>
<h3 id="tuple用例">tuple用例</h3>
<blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041831968.png" alt="image-20220304183145646"></p>
</blockquote>
<p>tie(i1, f1, s1) = t3; 将t3的数据取出来赋值</p>
<p>下图中</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Values</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">tuple</span><span class="p">;</span><span class="k">template</span><span class="o">&lt;&gt;</span> <span class="k">class</span> <span class="nc">tuple</span><span class="o">&lt;&gt;</span> <span class="p">{};</span>	<span class="c1">// 终止条件// 接受任意个Tail类template&lt;typename Head, typename... Tail&gt;class tuple&lt;Head, Tail...&gt; : private tuple&lt;Tail...&gt; {	// 继承它自己，形成递归	typedef tuple&lt;Tail...&gt; inherited;public:    tuple() {}    tuple(Head v, Tail... vtail) : m_head(v), inherited(vtail...) {}        typename Head::type head() { return m_head; }    inherited&amp; tail() { return *this; }protected:     Head m_head;}; 
</span></code></pre></td></tr></table>
</div>
</div><p>Tuple，元之组合，数之组合</p>
<blockquote>
<blockquote>
<p>Modern C++ Design</p>
</blockquote>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041832415.png" alt="image-20220304183232556"></p>
<h3 id="type-traits">type traits</h3>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041832027.png" alt="image-20220304183242063"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041832091.png" alt="image-20220304183252272"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041833959.png" alt="image-20220304183309685"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041833827.png" alt="image-20220304183328527"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041833892.png" alt="image-20220304183338971"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041833625.png" alt="image-20220304183351806"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041834069.png" alt="image-20220304183409114"></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">Zoo</span><span class="p">(</span><span class="k">const</span> <span class="n">Zoo</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>	<span class="c1">// 拷贝构造函数，delete表示写出来就delete了Zoo(Zoo&amp;&amp;)  = default; 	// &amp;&amp; move, 这是move constructorZoo&amp; operator=(const Zoo&amp;) = default;	// 拷贝赋值Zoo&amp; operator=(const Zoo&amp;&amp;) = delete;
</span></code></pre></td></tr></table>
</div>
</div><p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041834669.png" alt="image-20220304183420862"></p>
<p>复数只有实部和虚部。 不用写析构函数，默认生成，不重要，所以**__has_trivial_destructor = 1。**</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041834280.png" alt="image-20220304183431224"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041834212.png" alt="image-20220304183440134"></p>
<h4 id="type-traits实现-is_void">type traits，实现 is_void</h4>
<p>特化是泛化的范围缩小。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041834183.png" alt="image-20220304183450297"></p>
<h4 id="type-traits实现-is_integral">type traits，实现 is_integral</h4>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041835049.png" alt="image-20220304183503000"></p>
<h4 id="type-traits实现is_class-is_union-is_enum-is_pod">type traits，实现is_class, is_union, is_enum, is_pod</h4>
<p>这些在 C++标准库源代码中没有出现，可能是编译器做的这些事。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041835669.png" alt="image-20220304183516673"></p>
<h4 id="type-traits实现is_move_assignable">type traits，实现is_move_assignable</h4>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041835847.png" alt="image-20220304183528895"></p>
<h3 id="cout">cout</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">extern</span> <span class="n">_IO_ostream_withassign</span> <span class="n">cout</span><span class="p">;</span> 	<span class="c1">// extern表示可以被外部文件看见
</span></code></pre></td></tr></table>
</div>
</div><p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041835725.png" alt="image-20220304183540863"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041835184.png" alt="image-20220304183549041"></p>
<h3 id="moveable元素对各种容器速度效能的影响">moveable元素对各种容器速度效能的影响</h3>
<blockquote>
<p>速度跟机器实际内存也有关系。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">M</span> <span class="n">c1</span><span class="p">;...</span><span class="n">M</span> <span class="n">c11</span><span class="p">(</span><span class="n">c1</span><span class="p">);</span>	<span class="c1">// copyM c12(std::move(c1)); // move copy  c11.swap(c12);
</span></code></pre></td></tr></table>
</div>
</div><p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041836561.png" alt="image-20220304183600752"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041836621.png" alt="image-20220304183616768"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041836531.png" alt="image-20220304183628442"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041836738.png" alt="image-20220304183641622"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041837931.png" alt="image-20220304183705185"></p>
<h4 id="写一个moveable-class">写一个moveable class</h4>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041838780.png" alt="image-20220304183809785"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041838060.png" alt="image-20220304183820200"></p>
<p><strong>move copy浅拷贝，只是将新的指针指向原来的数据。</strong></p>
<p><strong>copy深拷贝，将数据和指针都移动到新的位置。（<u>必须保证原来的不会被用到</u>）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041838104.png" alt="image-20220304183832184"></p>
<p>vector本身的拷贝copy ctor是<strong>深拷贝</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041838272.png" alt="image-20220304183843324"></p>
<p>vector的move ctor是浅拷贝，只是swap三根指针。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203041838021.png" alt="image-20220304183852112"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fzhiy/images/imgs202203042025511.png" alt="image-20220304202553363"></p>
<h1 id="参考资料-1">参考资料</h1>
<ul>
<li>
<p><a href="https://www.bilibili.com/video/av714361076/?spm_id_from=333.788.b_765f64657363.2">https://www.bilibili.com/video/av714361076/?spm_id_from=333.788.b_765f64657363.2</a></p>
</li>
<li>
<p>视频代码-GitHub：https://github.com/19PDP/Bilibili-plus</p>
</li>
<li>
<p>STL源码剖析</p>
</li>
</ul>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">fzhiy</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2022-03-05
        
    </span>
  </p>
  
  
</div>
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">赞赏支持</label>
  <div class="qr-code">
    
    <label class="qr-code-image" for="reward">
        <img class="image" src="https://img.fzhiy.net/img/20200812154839.png">
        <span>微信打赏</span>
      </label>
    <label class="qr-code-image" for="reward">
        <img class="image" src="https://img.fzhiy.net/img/20200812154858.png">
        <span>支付宝打赏</span>
      </label>
  </div>
</div><footer class="post-footer">
      
      <nav class="post-nav">
        
        <a class="next" href="/post/2022-09-03-%E5%9F%BA%E4%BA%8Eelk&#43;kafka%E6%90%AD%E5%BB%BA%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%9D%E6%AD%A5%E5%AE%9E%E7%8E%B0/">
            <span class="next-text nav-default">基于ELK&#43;Kafka搭建日志平台架构设计与初步实现</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="fzhiy/blog"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:fzhiy270@163.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/fzhiy" class="iconfont icon-github" title="github"></a>
      <a href="https://blog.csdn.net/feng_zhiyu" class="iconfont icon-csdn" title="csdn"></a>
      <a href="https://www.zhihu.com/people/ni-feng-88-10" class="iconfont icon-zhihu" title="zhihu"></a>
  <a href="https://blog.fzhiy.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> 本站总访问量 <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次 </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> 本站总访客数 <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 人 </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2020 - 
    2023<span class="heart"><i class="iconfont icon-heart"></i></span><span>fzhiy</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.min.js" integrity="sha256-jwCP0NAdCBloaIWTWHmW4i3snUNMHUNO+jr9rYd2iOI=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.locales.min.js" integrity="sha256-ZwofwC1Lf/faQCzN7nZtfijVV6hSwxjQMwXL4gn9qU8=" crossorigin="anonymous"></script>
  <script><!-- NOTE: timeago.js uses the language code format like "zh_CN" (underscore and case sensitive) -->
    var languageCode = "en".replace(/-/g, '_').replace(/_(.*)/, function ($0, $1) {return $0.replace($1, $1.toUpperCase());});
    timeago().render(document.querySelectorAll('.timeago'), languageCode);
    timeago.cancel();  
  </script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>

<script id="baidu_analytics">
  var _hmt = _hmt || [];
  (function() {
    if (window.location.hostname === 'localhost') return;
    var hm = document.createElement("script"); hm.async = true;
    hm.src = "https://hm.baidu.com/hm.js?e4ff802fe8f2731918ababdb4ccf87bc";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>

<script id="baidu_push">
  (function(){
    if (window.location.hostname === 'localhost') return;
    var bp = document.createElement('script'); bp.async = true;
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
      bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
  })();
</script>




</body>
</html>

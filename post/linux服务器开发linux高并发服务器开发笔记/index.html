<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>[Linux服务器开发]Linux高并发服务器开发笔记 - fzhiy&#39;s blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="fzhiy" /><meta name="description" content="1.Linux系统编程入门 GCC工作流程 GCC常用参数选项 使用如： 1 2 3 gcc test.c -E -o test.i #预处理源文件 gcc test.i -S -o test.s # 编译经过预处理的源文件test." /><meta name="keywords" content="Linux, 服务器开发" />






<meta name="generator" content="Hugo 0.88.1 with theme even" />


<link rel="canonical" href="https://blog.fzhiy.net/post/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91linux%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="[Linux服务器开发]Linux高并发服务器开发笔记" />
<meta property="og:description" content="1.Linux系统编程入门 GCC工作流程 GCC常用参数选项 使用如： 1 2 3 gcc test.c -E -o test.i #预处理源文件 gcc test.i -S -o test.s # 编译经过预处理的源文件test." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.fzhiy.net/post/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91linux%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-04-20T12:39:35+08:00" />
<meta property="article:modified_time" content="2022-04-20T12:39:35+08:00" />

<meta itemprop="name" content="[Linux服务器开发]Linux高并发服务器开发笔记">
<meta itemprop="description" content="1.Linux系统编程入门 GCC工作流程 GCC常用参数选项 使用如： 1 2 3 gcc test.c -E -o test.i #预处理源文件 gcc test.i -S -o test.s # 编译经过预处理的源文件test."><meta itemprop="datePublished" content="2022-04-20T12:39:35+08:00" />
<meta itemprop="dateModified" content="2022-04-20T12:39:35+08:00" />
<meta itemprop="wordCount" content="8703">
<meta itemprop="keywords" content="Linux," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="[Linux服务器开发]Linux高并发服务器开发笔记"/>
<meta name="twitter:description" content="1.Linux系统编程入门 GCC工作流程 GCC常用参数选项 使用如： 1 2 3 gcc test.c -E -o test.i #预处理源文件 gcc test.i -S -o test.s # 编译经过预处理的源文件test."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">fzhiy&#39;s blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a><a href="/links/">
        <li class="mobile-menu-item">友链</li>
      </a><a href="https://home.fzhiy.net">
        <li class="mobile-menu-item">主页</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">fzhiy&#39;s blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/links/">友链</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="https://home.fzhiy.net">主页</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">[Linux服务器开发]Linux高并发服务器开发笔记</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-04-20 </span>
        <div class="post-category">
            <a href="/categories/linux/"> Linux </a>
            </div>
          <span class="more-meta"> 约 8703 字 </span>
          <span class="more-meta"> 预计阅读 18 分钟 </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次阅读 </span>
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#1linux系统编程入门">1.Linux系统编程入门</a></li>
        <li><a href="#2linux多进程开发">2.Linux多进程开发</a></li>
        <li><a href="#3linux多线程开发">3.Linux多线程开发</a></li>
        <li><a href="#4linux网络编程">4.Linux网络编程</a></li>
        <li><a href="#5项目实战与总结">5.项目实战与总结</a></li>
        <li><a href="#参考资料">参考资料</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="1linux系统编程入门">1.Linux系统编程入门</h2>
<p><img src="https://img.fzhiy.net/img/202204160950633.png" alt="image-20220416095019121"></p>
<ul>
<li>
<p>GCC工作流程</p>
<p><img src="https://img.fzhiy.net/img/202204160953290.png" alt="image-20220416095303150"></p>
</li>
<li>
<p>GCC常用参数选项</p>
<p><img src="https://img.fzhiy.net/img/202204160956865.png" alt="image-20220416095646595"></p>
<p><img src="https://img.fzhiy.net/img/202204161032383.png" alt="image-20220416103240998"></p>
<p>使用如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">gcc test.c -E -o test.i	<span class="c1">#预处理源文件</span>
gcc test.i -S -o test.s <span class="c1"># 编译经过预处理的源文件test.i，但不进行汇编</span>
gcc test.s -s -o a
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>两种库文件：<strong>静态库</strong> 和 <strong>动态库（共享库）</strong>。区别：</p>
<ul>
<li><strong>静态库</strong>在程序的链接阶段被复制到程序中；</li>
<li><strong>动态库</strong>在链接阶段没有被复制到程序中，而是程序<strong>在运行时由系统动态加载到内存中</strong>供程序调用。</li>
</ul>
<p>库的好处：1）代码保密；2）方便部署和分发。</p>
</li>
<li>
<p>静态库的制作</p>
<ul>
<li>
<p>命名规则：</p>
<ul>
<li>
<p>Linux：<strong>libxxx.a</strong></p>
<ul>
<li>lib : 前缀（固定）</li>
<li><strong>xxx : 库的名字，自己起</strong></li>
<li>.a : 后缀（固定）</li>
</ul>
</li>
<li>
<p>Windows：<strong>libxxx.lib</strong></p>
</li>
</ul>
</li>
<li>
<p>静态库制作</p>
<ul>
<li>
<p>gcc获得.o文件； gcc -c xxx.c -I 路径</p>
</li>
<li>
<p>将.o文件打包，使用ar工具（archive）</p>
<p><strong>ar rcs libxxx.a xxx.o xxx.o</strong></p>
<ul>
<li>r 将文件插入备存文件中；</li>
<li>c 建立备存文件；</li>
<li>s 索引。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>静态库的使用</p>
<ul>
<li>gcc main.c -o app -I ./include/ -L ./lib/ -l 库名称</li>
<li>-I 头文件所在目录</li>
<li>-l 搜索使用的库名称</li>
<li>-L 库路径</li>
</ul>
</li>
<li>
<p>动态库的制作和使用</p>
<ul>
<li>
<p>制作</p>
<ul>
<li>
<p>命名规则：</p>
<ul>
<li>
<p>Linux：<strong>libxxx.so</strong></p>
<ul>
<li>lib: 固定前缀</li>
<li>xxx : 库的名字，自己起</li>
<li>.so ：固定后缀</li>
</ul>
<p>在Linux下是一个可执行文件</p>
</li>
<li>
<p>Windows：<strong>libxxx.dll</strong></p>
</li>
</ul>
</li>
<li>
<p>动态库的制作</p>
<ul>
<li>
<p>gcc得到.o文件，得到和位置无关的代码</p>
<p><strong>gcc -c -fpic/-fPIC a.c b.c</strong></p>
</li>
<li>
<p>gcc 得到动态库</p>
<p><strong>gcc -shared a.o b.o -o libcalc.so</strong></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>静态库 与 动态库的工作原理</p>
<ul>
<li>
<p>静态库：GCC进行链接时，会把静态库中的代码打包到可执行程序中</p>
</li>
<li>
<p>动态库：GCC进行链接时，动态库的代码<strong>不会被打包到可执行程序</strong>中</p>
</li>
<li>
<p>程序启动之后，<strong>动态库会被动态加载到内存中</strong>，通过 **ldd(list dynamic dependencies)**命令检查动态库依赖关系</p>
</li>
<li>
<p>如何定位共享库文件呢？</p>
<p>当系统加载可执行代码的时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时需要系统的动态载入器来获取该绝对路径。对于elf格式的可执行程序，是由 <strong>ld-linux.so</strong>来完成的，它先后搜索elf文件的 <strong>DT_RPATH段 =&gt; 环境变量 LD_LIBRARY_PATH =&gt; /etc/ld.so.cache</strong>文件列表  =&gt; <strong>/lib/,  /usr/lib</strong> 目录找到库文件后将其载入内存。【不推荐使用第三种方式，系统自带了文件，可能同名】</p>
</li>
</ul>
</li>
<li>
<p>静态库 和 动态库 的对比</p>
<ul>
<li>
<p>程序编译成可执行程序的过程</p>
<p><img src="https://img.fzhiy.net/img/202204161539613.png" alt="image-20220416153939567"></p>
</li>
<li>
<p>静态库制作过程</p>
<p><img src="https://img.fzhiy.net/img/202204161541189.png" alt="image-20220416154128135"></p>
</li>
<li>
<p>动态库制作过程 （<strong>-fpic/-fPIC 生成与位置无关的目标代码</strong>）</p>
<p><img src="https://img.fzhiy.net/img/202204161542894.png" alt="image-20220416154238813"></p>
</li>
<li>
<p>静态库的优缺点</p>
<ul>
<li>优点：
<ul>
<li>静态库被打包到应用程序中加载速度快</li>
<li>发布程序无需提供静态库，移植方便；</li>
</ul>
</li>
<li>缺点：
<ul>
<li>消耗系统资源，浪费内存；</li>
<li>更新、部署、发布麻烦</li>
</ul>
</li>
</ul>
<p><img src="https://img.fzhiy.net/img/202204161547731.png" alt="image-20220416154745774"></p>
</li>
<li>
<p>动态库的优缺点</p>
<ul>
<li>优点：
<ul>
<li>可以实现进程间资源共享（共享库）</li>
<li>更新、部署、发布简单</li>
<li>可以控制何时加载动态库</li>
</ul>
</li>
<li>缺点：
<ul>
<li>加载速度比静态库慢；</li>
<li>发布程序时需要提供依赖的动态库。</li>
</ul>
</li>
</ul>
<p><img src="https://img.fzhiy.net/img/202204161550539.png" alt="image-20220416155035110"></p>
</li>
</ul>
</li>
<li>
<p>Makefile</p>
<p>Makefile文件定<u>义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至进行更复杂的功能操作</u>，因为Makefile文件就像一个Shell脚本一样，也可以执行操作系统的命令。</p>
<p>好处：“<strong>自动化编译</strong>”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。 make 是一个命令工具，是一个解释 Makefile文件中指令的命令工具，一般来说，大多数的 IDE 都有这个命令， 比如Delphi 的make，Visual C++的 nmake， Linux下 GNU 的make。</p>
<ul>
<li>
<p>Makefile文件命名和规则</p>
<ul>
<li>
<p>文件命名</p>
<ul>
<li>makefile或者Makefile</li>
</ul>
</li>
<li>
<p>Makefile 规则</p>
<ul>
<li>
<p>一个Makefile 文件中可以有一个或者多个规则</p>
<p><strong>目标 &hellip; : 依赖 &hellip;</strong></p>
<p>​		<strong>命令（shell命令）</strong></p>
<p>​		<strong>&hellip;</strong></p>
<ul>
<li>目标：最终要生成的文件（伪目标除外）</li>
<li>依赖：生成目标所需要的文件或是目标</li>
<li>命令：通过执行命令对依赖操作生成目标（<strong>命令前必须Tab缩进</strong>）</li>
</ul>
</li>
<li>
<p>Makefile 中的其他规则一般都是为第一条规则服务的。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>工作原理</p>
<ul>
<li>
<p>命令在<strong>执行之前，需要先检查规则中的依赖是否存在</strong></p>
<ul>
<li>如果存在，执行命令；</li>
<li>如果不存在，向下检查其他的规则，检查有没有一个规则是用来生成这个依赖的，如果找到了，则执行该规则中的命令</li>
</ul>
</li>
<li>
<p><strong>检查更新</strong>，在执行规则中的命令时，会比较目标和依赖文件的时间；</p>
<ul>
<li>如果依赖的时间比目标的时间<strong>晚</strong>，<strong>需要重新生成目标</strong>；</li>
<li>如果依赖的时间比目标的时间早，目标不需要重新更新，对应规则中的命令不需要被执行。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>变量</p>
<ul>
<li>
<p>自定义变量</p>
<ul>
<li>变量名 = 变量值  var = hello</li>
</ul>
</li>
<li>
<p>预定义变量</p>
<p>AR ：归档维护程序的名称，默认值为ar</p>
<p>CC：C编译器的名称，默认值为cc</p>
<p>CXX：C++编译器的名称，默认值为g++</p>
<p>$@：目标的完整名称									# <strong>自动变量只能在规则的命令中使用</strong></p>
<p>$&lt;：第一个依赖文件的名称</p>
<p>$^：所有的依赖文件</p>
</li>
<li>
<p>获取变量的值</p>
<p>$(变量名)</p>
<p><img src="https://img.fzhiy.net/img/202204171020497.png" alt="image-20220417102016131"></p>
</li>
</ul>
</li>
<li>
<p>模式匹配</p>
<p><img src="https://img.fzhiy.net/img/202204171023216.png" alt="image-20220417102353020"></p>
</li>
<li>
<p>函数</p>
<ul>
<li>
<p>$(wildcard PATTERN&hellip;)</p>
</li>
<li>
<p>功能：获取指定目录下指定类型的文件列表；</p>
</li>
<li>
<p>参数：PATTERN指的是某个或多个目录下的对应的某种类型的文件，如果有多个目录，一般使用空格间隔；</p>
</li>
<li>
<p>返回：得到的若干个文件的文件列表，文件名之间使用空格间隔</p>
</li>
</ul>
<p>示例：</p>
<p>​	*<em>$(wildcard <em>.c ./sub/*.c)</em></em></p>
<p>​	返回值格式：a.c b.c c.c d.c e.c f.c</p>
<ul>
<li>$(patsubst <pattern>, <replacement>, <text>)</li>
<li>功能：查找<text>中的单词（单词以“空格”、“Tab”或“回车”“换行”分割）是否符合模式<pattern>，如果匹配的话，则以<replacement>替换；</li>
<li><pattern>可以包括通配符<code>%</code>, 表示任意长度大的字符串。如果<replacement>中也包含<code>%</code>，那么，<replacement>中的这个<code>%</code>将是<pattern>中的那个%所代表的字串。（可以用<code>\</code>来转移，以<code>%</code>来表示真实含义的<code>%</code>字符）</li>
<li>返回：函数返回被替换过后的字符串；</li>
</ul>
<p>示例：</p>
<p>​	<strong>$(patsubst %.c, %.o, x.c bar.c)</strong></p>
<p>​	返回值格式：x.o bar.o</p>
<p><strong>.PHONY</strong> 尾目标，可以用于最后的clean目标，用于删除 .o 目标文件</p>
</li>
</ul>
</li>
<li>
<p>GDB调试</p>
<ul>
<li>
<p>什么是GDB</p>
<p>一般来说，GDB主要帮助完成下面四个方面的功能：</p>
<ol>
<li>启动程序，可以按照自定义的要求随心所欲的运行程序</li>
<li>可让被调试的程序在所指定的位置的断点处停住（断点可以是条件表达式）</li>
<li>当程序被停住时，可以检查此时程序中所发生的事；</li>
<li>可以改变程序，将一个BUG产生的影响修正从而测试其他BUG</li>
</ol>
</li>
<li>
<p>准备工作</p>
<p>通常在为调试而编译时，会关掉编译器的优化选项<code>-o</code>，并打开调试选项<code>-g</code>。另外，<code>-Wall</code>在尽量不影响程序行为的情况下选项打开所有warning，也可以发现许多问题，避免一些不必要的BUG。</p>
<p><strong>gcc -g -Wall program.c -o program</strong></p>
<p><code>-g</code>的作用是在<strong>可执行文件中加入源代码的信息</strong>，比如 可执行文件中第几条机器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，所以在调试时必须保证 gdb 能找到源文件。</p>
</li>
<li>
<p>GDB命令 —— 启动、退出、查看代码</p>
<ul>
<li>
<p>启动和退出</p>
<p>gdb 可执行程序</p>
<p>quit</p>
</li>
<li>
<p>给程序设置参数 / 获取设置参数</p>
<p>set args 10 20</p>
<p>show args</p>
</li>
<li>
<p>GDB 使用帮助 help</p>
</li>
<li>
<p>查看当前文件代码</p>
<p>list/l （从默认位置显示）</p>
<p>list/l 行号（从指定的行显示）</p>
<p>list/l 函数名（从指定的函数显示）</p>
</li>
<li>
<p>查看非当前文件代码</p>
<p>list/l 文件名:行号</p>
<p>list/l 文件名:函数名</p>
</li>
<li>
<p>设置显示的行数</p>
<p>show list/listsize</p>
<p>set list/listsize行数</p>
</li>
</ul>
</li>
<li>
<p>GDB命令——断点操作</p>
<ul>
<li>
<p>设置断点</p>
<p>b/break 行号</p>
<p>b/break 函数名</p>
<p>b/break 文件名:行号</p>
<p>b/break 文件名:函数</p>
</li>
<li>
<p>查看断点</p>
<p>i/info b/break</p>
</li>
<li>
<p>删除断点</p>
<p>d/del/delete 断点编号</p>
</li>
<li>
<p>设置断点无效</p>
<p>dis/disable 断点编号</p>
</li>
<li>
<p>设置断点生效</p>
<p>ena/enable 断点编号</p>
</li>
<li>
<p>设置条件断点（一般用在循环的位置）</p>
<p>b/break 10 if i == 5</p>
</li>
</ul>
</li>
<li>
<p>GDB命令——调试命令</p>
<ul>
<li>
<p>运行GDB程序</p>
<p>start （程序停在第一行）</p>
<p>run（遇到断点才停）</p>
</li>
<li>
<p>继续运行，到下一个断点停</p>
<p>c/continue</p>
</li>
<li>
<p>向下执行一行代码（不会进入函数体）</p>
<p>n/next</p>
</li>
<li>
<p>变量操作</p>
<p>p/print 变量名（打印变量值）</p>
<p>ptype 变量名（打印变量类型）</p>
</li>
<li>
<p>向下单步调试（遇到函数进入函数体）</p>
<p>s/step</p>
<p>finish（跳出函数体）</p>
</li>
<li>
<p>自动变量操作</p>
<p>display num（自动打印变量的值）</p>
<p>i/info display</p>
<p>undisplay 编号</p>
</li>
<li>
<p>其他操作</p>
<p>set var 变量名=变量值</p>
<p>until （跳出循环）</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>文件IO</p>
<ul>
<li>
<p>标准C库IO函数 （可以跨平台）</p>
<p><img src="https://img.fzhiy.net/img/202204202125271.png" alt="image-20220420212556936"></p>
</li>
<li>
<p>标准C库IO和Linux系统IO的关系 （调用和被调用）</p>
<p><img src="https://img.fzhiy.net/img/202204202136219.png" alt="image-20220420213652006"></p>
</li>
<li>
<p>虚拟地址空间</p>
<p><img src="https://img.fzhiy.net/img/202204202142104.png" alt="image-20220420214211970"></p>
<p>MMU（内存管理单元）将虚拟地址映射到物理地址。</p>
</li>
<li>
<p>文件描述符</p>
<p><img src="https://img.fzhiy.net/img/202204202152663.png" alt="image-20220420215257544"></p>
</li>
<li>
<p>Linux 系统IO函数</p>
<p>标准C库的 API，使用 <code>man 3 函数名</code>查看，Linux 系统IO函数，使用<code>man 2 函数名</code>查看说明。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="n">mode_t</span> <span class="n">mode</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">close</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">);</span>
<span class="n">ssize_t</span> <span class="nf">read</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">count</span><span class="p">);</span>
<span class="n">ssize_t</span> <span class="nf">write</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">count</span><span class="p">);</span>
<span class="n">off_t</span> <span class="nf">lseek</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">off_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">whence</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>stat结构体</p>
<p><img src="https://img.fzhiy.net/img/202204212126311.png" alt="image-20220421212627185"></p>
</li>
<li>
<p>st_mode变量</p>
<p><img src="https://img.fzhiy.net/img/202204212128183.png" alt="image-20220421212801173"></p>
</li>
</ul>
</li>
<li>
<p>模拟实现 <code>ls -l</code>命令 （<strong>见lesson12的 <code>ls-l.c</code></strong>）</p>
</li>
<li>
<p>文件属性操作函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">access</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">chmod</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">chown</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">uid_t</span> <span class="n">owner</span><span class="p">,</span> <span class="n">gid_t</span> <span class="n">group</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">truncate</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">off_t</span> <span class="n">length</span><span class="p">);</span>	<span class="c1">// 缩减或扩展文件的尺寸至指定的大小
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>目录操作函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">mkdir</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span> <span class="n">mode_t</span> <span class="n">mode</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">rmdir</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">rename</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">oldpath</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">newpath</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">chdir</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">);</span>
<span class="kt">char</span> <span class="o">*</span><span class="nf">getcwd</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">size</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>目录遍历函数</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">DIR</span> <span class="o">*</span><span class="nf">opendir</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">dirent</span> <span class="o">*</span><span class="nf">readdir</span><span class="p">(</span><span class="n">DIR</span> <span class="o">*</span><span class="n">dirp</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">closedir</span><span class="p">(</span><span class="n">DIR</span> <span class="o">*</span><span class="n">dirp</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>dirent结构体和d_type</p>
<p><img src="https://img.fzhiy.net/img/202204221050441.png" alt="image-20220422105027384"></p>
<ul>
<li>
<p>dup、dup2函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">dup</span><span class="p">(</span><span class="kt">int</span> <span class="n">oldfd</span><span class="p">);</span>	<span class="c1">// 复制文件描述符
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">dup2</span><span class="p">(</span><span class="kt">int</span> <span class="n">oldfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">newfd</span><span class="p">);</span>	<span class="c1">// 重定向文件描述符
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>fcntl函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">fcntl</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="p">...</span> <span class="cm">/* arg */</span><span class="p">);</span>
<span class="c1">// 复制文件描述符，
</span><span class="c1">// 设置/获取文件的状态标志
</span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h2 id="2linux多进程开发">2.Linux多进程开发</h2>
<ul>
<li>
<p>进程概述</p>
<ul>
<li>
<p>程序和进程</p>
<ul>
<li>程序（<strong>占用磁盘大小，不占用内存和CPU资源</strong>）是 包含一系列信息的文件，这些信息描述了如何在运行时创建一个进程。（二进制格式标识、机器语言指令、程序入口地址、数据、符号表及重定位表、共享库和动态链接信息 和 其他信息。）</li>
<li>进程（<strong>占用内存资源和CPU资源</strong>） 是正在运行的程序的实例。</li>
</ul>
</li>
<li>
<p>单道、多道程序设计</p>
<ul>
<li>单道程序，即在计算机内存中只允许一个程序运行；</li>
<li>引入多道程序设计技术的 <strong>根本目的</strong>是 <strong>为了提高CPU的利用率。</strong></li>
</ul>
</li>
<li>
<p>时间片（timeslice）</p>
<ul>
<li>又称为 “量子（quantum）”或“处理器片（processor slice）” 是操作系统分配给每个正在运行的微观上的一段CPU时间。</li>
<li>时间片 由 <strong>操作系统内核的调度程序</strong>分配给每个进程。</li>
</ul>
</li>
<li>
<p>并行和并发</p>
</li>
<li>
<p>进程控制块（PCB）</p>
<ul>
<li>
<p>Linux内核的进程控制块是 task_struct 结构体。</p>
</li>
<li>
<p>其内部成员(需要掌握的)有：</p>
<p><img src="https://img.fzhiy.net/img/202204231502499.png" alt="image-20220423150234361"></p>
</li>
<li>
<p>当前工作目录</p>
</li>
<li>
<p>umask掩码</p>
</li>
<li>
<p>文件描述符表，包含很多指向file结构体的指针</p>
</li>
<li>
<p>和信号相关的信息</p>
</li>
<li>
<p>用户id和组id</p>
</li>
<li>
<p>会话（session）和进程组</p>
</li>
<li>
<p>进程可以使用的资源上限（<code>ulimit -a</code>）</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>进程状态转换</p>
<ul>
<li>
<p>进程的状态</p>
<ul>
<li>
<p>在三态模型中，分为三个基本状态：就绪态、运行态、阻塞态。</p>
<p><img src="https://img.fzhiy.net/img/202204231547033.png" alt="image-20220423154753716"></p>
</li>
<li>
<p>在五态模型中，分为新建态、就绪态、运行态、阻塞态、终止态。</p>
<p><img src="https://img.fzhiy.net/img/202204270947799.png" alt="image-20220427094737444"></p>
</li>
</ul>
</li>
<li>
<p>进程相关命令</p>
<ul>
<li>
<p>查看进程</p>
<ul>
<li>
<p>ps aux / ajx</p>
<p>a：显示终端上的所有进程，包括其他用户的进程</p>
<p>u：<strong>显示进程的详细信息</strong></p>
<p>x：显示没有控制终端的进程</p>
<p>j：列出<strong>与作业控制相关的信息</strong></p>
<p><img src="https://img.fzhiy.net/img/202204271010427.png" alt="image-20220427101042933"></p>
</li>
<li>
<p>STAT参数意义</p>
<p>D				不可中断 Uninterruptible (usually IO)</p>
<p>R 				正在运行，或 在队列中的进程</p>
<p>S（大写） 出于休眠状态</p>
<p>T				停止 或 被追踪</p>
<p>Z				僵尸进程</p>
<p>W				进入内存交换（从内核2.6开始无效）</p>
<p>X				死掉的进程</p>
<p>&lt;				高优先级</p>
<p>N				低优先级</p>
<p>s(小写)  	 包含子进程</p>
<p>+                 位于 前台的进程组</p>
</li>
<li>
<p>实时显示进程状态</p>
<p>top</p>
<p>可以在使用 <code>top</code> 命令时加上 <code>-d</code>来指定显示信息更新的事件间隔，在<code>top</code>命令执行后，可以按以下按键对显示的结果进行排序：</p>
<ul>
<li>M	根据内存使用量排序</li>
<li>P     根据 CPU 占用率排序</li>
<li>T     根据进程运行事件长短排序</li>
<li>U     根据用户名来筛选进程</li>
<li>K      输入指定的PID杀死进程</li>
</ul>
</li>
<li>
<p>杀死进程</p>
<p>kill [-signal] pid</p>
<p>kill -l 列出所有信号</p>
<p>kill -SIGKILL  进程ID</p>
<p>kill -9 进程ID （强制杀死某个进程）</p>
<p>killall name 根据进程名杀死进程</p>
<p><img src="https://img.fzhiy.net/img/202204271022091.png" alt="image-20220427102217992"></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>进程号和相关函数</p>
<p><img src="https://img.fzhiy.net/img/202204271027382.png" alt="image-20220427102606767"></p>
</li>
</ul>
</li>
<li>
<p>进程创建</p>
<ul>
<li>
<p>系统允许一个进程创建子进程，新进程即为子进程，子进程还可以创建新的子进程，形成<u>进程树结构模型</u>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="n">pid_t</span> <span class="nf">fork</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
<p>父子进程指定代码的情况：</p>
<p><img src="https://img.fzhiy.net/img/202204271052167.png" alt="image-20220427105213977"></p>
</li>
<li>
<p>父子进程虚拟地址空间情况</p>
<p><img src="https://img.fzhiy.net/img/202204271058413.png" alt="image-20220427105840251"></p>
<p>父子进程中的变量在各自的栈空间中，互不影响。</p>
<p><strong>读时共享</strong>父进程虚拟地址空间，<strong>写时拷贝</strong>。</p>
<p><img src="https://img.fzhiy.net/img/202204271106224.png" alt="image-20220427110620205"></p>
</li>
<li>
<p>父子进程关系以及GDB多进程调试</p>
</li>
<li>
<p>父子进程关系</p>
<p><img src="https://img.fzhiy.net/img/202204271113956.png" alt="image-20220427111326013"></p>
</li>
<li>
<p>GDB多进程调试（面试考 调试命令）</p>
<p>使用GDB调试时，GDB默认只能跟踪一个进程，可以在fork函数调用之前，通过指令设置GDB调试工具跟踪父进程或子进程，<strong>默认跟踪父进程。</strong></p>
<p>设置调试父进程或子进程： <code>set follow-fork-mode [parent(默认) | child]</code></p>
<p>设置调试模式： <code>set detach-on-fork [on | off]</code></p>
<p>​	<strong>默认为on</strong>，表示调试当前进程时，其他的进程继续运行；如果为off，调试当前进程时，其他进程被GDB挂起。</p>
<p>查看调试的进程：info inferiors</p>
<p>切换当前调试的进程：inferior id</p>
<p>使进程脱离GDB调试：detach inferiors id</p>
</li>
<li>
<p>exec函数簇</p>
<ul>
<li>
<p>作用：根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部内执行一个可执行文件。</p>
</li>
<li>
<p>exec函数簇的函数执行册成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代，只留下进程ID等一些表面上的信息仍保持原样，颇有些“三十六计”中的“金蝉脱壳”。看上去还是旧的躯壳，却已经注入了新的灵魂。只有调用失败了，他们才会返回-1，从原程序的调用点接着往下执行。</p>
<p><img src="https://img.fzhiy.net/img/202204271940946.png" alt="image-20220427194028639"></p>
<p><img src="https://img.fzhiy.net/img/202204271942258.png" alt="image-20220427194202915"></p>
</li>
</ul>
</li>
<li>
<p>进程退出、孤儿进程、僵尸进程</p>
<ul>
<li>
<p>进程退出</p>
<p><img src="https://img.fzhiy.net/img/202204272008608.png" alt="image-20220427200814249"></p>
</li>
<li>
<p>孤儿进程</p>
<ul>
<li>父进程运行结束，但子进程还在运行（未运行结束），这样的子进程称为 孤儿进程（Orphan Process）</li>
<li>每当出现一个孤儿进程的时候，<strong>内核</strong>就<strong>把孤儿进程的父进程设置为 init</strong>， 而init进程会循环地 <strong>wait()</strong> 它的已退出地子进程。这样，当一个孤儿进程凄凉地结束其声明周期地时候，init进程就会代表党和政府出面处理它地一切善后工作。</li>
<li>因此<strong>孤儿进程并不会有什么危害</strong>。</li>
</ul>
</li>
<li>
<p>僵尸进程</p>
<ul>
<li>每个结束后，都会释放自己地址空间中的用户区数据，内核区的 PCB 没有办法自己释放掉，需要父进程去释放。</li>
<li>进程终止时，父进程尚未回收，子进程残留资源（PCB）存放在内核中，变成僵尸（<strong>Zombie</strong>）进程。</li>
<li>僵尸进程不能被 <code>kill -9</code> 杀死。</li>
<li>这样会导致一个问题，<strong>如果父进程不调用wait() 或 waitpid() 的话</strong>，那么<strong>保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的</strong>，<strong>如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程</strong>，此即为僵尸进程的危害，应当避免。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>wait函数</p>
<p><img src="https://img.fzhiy.net/img/202204272121606.png" alt="image-20220427212124418"></p>
<ul>
<li>
<p>进程回收</p>
<p><img src="https://img.fzhiy.net/img/202204272037520.png" alt="image-20220427203725270"></p>
<p>wait() 和 waitpid() 函数的功能一样，区别在于，<strong>wait()函数会阻塞，waitpid() 可以设置不阻塞，waitpid() 还可以指定等待哪个子进程结束。</strong></p>
<p>注意：<strong>一次wait或waitpid 调用只能清理一个子进程，清理多个子进程应使用循环。</strong></p>
</li>
<li>
<p>退出信息相关宏函数</p>
<p><img src="https://img.fzhiy.net/img/202204272056469.png" alt="image-20220427205601479"></p>
</li>
</ul>
</li>
<li>
<p>waitpid函数</p>
<p><img src="https://img.fzhiy.net/img/202204272121305.png" alt="image-20220427212106011"></p>
</li>
<li>
<p>进程间通信简介</p>
<p><img src="https://img.fzhiy.net/img/202204272122641.png" alt="image-20220427212215193"></p>
<ul>
<li>
<p>进程间通信（<strong>IPC，Inter Processes Communication</strong>）的目的：</p>
<ul>
<li>数据传输：一个进程需要将它的数据发送给另一个进程；</li>
<li>通知事件：一个进程需要向另一个或一组进程发送消息，通知它（他们）发生了某种事件（如进程终止时要通知父进程）。</li>
<li>资源共享：多个进程之间共享同样的资源。为了做到这一点，需要内核提供<strong>互斥和同步</strong>机制。</li>
<li>进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</li>
</ul>
</li>
<li>
<p>Linux进程间通信的方式</p>
<p><img src="https://img.fzhiy.net/img/202204272129375.png" alt="image-20220427212921082"></p>
</li>
</ul>
</li>
<li>
<p>匿名管道概述</p>
<ul>
<li>
<p>匿名管道</p>
<ul>
<li>管道也叫 无名（匿名）管道，它是UNIX系统IPC的最古老形式，所有的UNIX系统都支持这种通信机制。</li>
<li>统计一个目录中文件的数目命令：<code>ls | wc -l</code>，为了执行改命令，shell 创建了两个进程来分别执行 <code>ls</code>和<code>wc</code>。</li>
</ul>
<p><img src="https://img.fzhiy.net/img/202204272132527.png" alt="image-20220427213246517"></p>
</li>
<li>
<p>管道的特点</p>
<p><img src="https://img.fzhiy.net/img/202204272137614.png" alt="image-20220427213754334"></p>
<p><img src="https://img.fzhiy.net/img/202204272141127.png" alt="image-20220427214129774"></p>
</li>
<li>
<p>为什么可以使用管道进行进程间通信？</p>
<p>因为 <strong>父子进程 共享文件描述符。</strong></p>
<p><img src="https://img.fzhiy.net/img/202204272144439.png" alt="image-20220427214457130"></p>
</li>
<li>
<p>管道的数据结构</p>
<p>循环队列 <img src="https://img.fzhiy.net/img/202204272146253.png" alt="image-20220427214652241"></p>
</li>
<li>
<p>匿名管道的使用</p>
<ul>
<li>
<p>创建匿名管道</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">pipe</span><span class="p">(</span><span class="kt">int</span> <span class="n">pipefd</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>查看管道缓冲大小命令</p>
<p><code>ulimit -a</code></p>
</li>
<li>
<p>查看管道缓冲大小函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">long</span> <span class="nf">fpathconf</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">name</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ul>
</li>
<li>
<p>父子进程通过匿名管道通信</p>
</li>
<li>
<p>匿名管道通信案例</p>
</li>
<li>
<p>管道的读写特点和管道设置为非阻塞</p>
</li>
<li>
<p>有名管道介绍及使用</p>
</li>
<li>
<p>有名管道实现简单版聊天功能</p>
</li>
<li></li>
</ul>
<h2 id="3linux多线程开发">3.Linux多线程开发</h2>
<ul>
<li>
<p>线程概述</p>
<ul>
<li>概述
<ul>
<li>进程是 CPU **分配资源的最小单位，**线程是 <strong>操作系统调度执行的最小单位。</strong></li>
<li>线程是<strong>轻量级的进程（LWP：Light Weight Process）</strong>，在<strong>Linux</strong>环境下线程的本质仍是进程。</li>
<li>查看指定进程的LWP号： <code>ps -Lf pid</code></li>
</ul>
</li>
<li>线程之间共享和非共享资源
<ul>
<li>共享资源
<ul>
<li>进程ID和父进程ID</li>
<li>进程组ID和会话ID</li>
<li>用户ID和用户组ID</li>
<li>文件描述符表</li>
<li>信号处置</li>
<li>文件系统的相关信息：文件权限掩码（umask）、当前工作目录</li>
<li>虚拟地址空间**（除栈、.text）**</li>
</ul>
</li>
<li>非共享资源
<ul>
<li>线程ID</li>
<li>信号掩码</li>
<li>线程特有数据</li>
<li>error变量</li>
<li>实时调度策略和优先级</li>
<li>栈，本地变量和函数的调用链接信息</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>创建线程</p>
<ul>
<li>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">pthread_create</span><span class="p">(</span><span class="n">pthread_t</span> <span class="o">*</span><span class="kr">thread</span><span class="p">,</span> <span class="k">const</span> <span class="n">pthread_attr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">start_routine</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>

</code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>
<p>终止线程</p>
</li>
<li>
<p>连接已终止的线程</p>
</li>
<li>
<p>线程的分离</p>
</li>
<li>
<p>线程取消</p>
</li>
<li>
<p>线程属性</p>
</li>
<li>
<p>线程同步</p>
</li>
<li>
<p>互斥锁</p>
</li>
<li>
<p>死锁</p>
</li>
<li>
<p>读写锁</p>
</li>
<li>
<p>生产者和消费者模型</p>
</li>
<li>
<p>条件变量</p>
</li>
<li>
<p>信号量</p>
</li>
</ul>
<h2 id="4linux网络编程">4.Linux网络编程</h2>
<ul>
<li>
<p>网络结构模式</p>
<ul>
<li>C/S结构</li>
<li>B/S结构</li>
</ul>
</li>
<li>
<p>MAC地址、IP地址、端口</p>
</li>
<li>
<p>网络模型</p>
<ul>
<li><img src="https://img.fzhiy.net/img/202204291451215.png" alt="image-20220429145118491"></li>
<li><img src="https://img.fzhiy.net/img/202204291451223.png" alt="image-20220429145129135"></li>
</ul>
</li>
<li>
<p>协议</p>
</li>
<li>
<p>网络通信的过程</p>
</li>
<li>
<p>socket介绍</p>
</li>
<li>
<p>字节序</p>
</li>
<li>
<p>字节序转换函数</p>
</li>
<li>
<p>socket地址</p>
</li>
<li>
<p>IP地址转换函数</p>
</li>
<li>
<p>TCP通信流程</p>
</li>
<li>
<p>socket函数</p>
</li>
<li>
<p>TCP通信实现（服务端）</p>
</li>
<li>
<p>TCP通信实现（客户端）</p>
</li>
<li>
<p>TCP三次握手</p>
</li>
<li>
<p>滑动窗口</p>
</li>
<li>
<p>TCP四次握手</p>
</li>
<li>
<p>多进程实现并发服务器</p>
</li>
<li>
<p>多线程实现并发服务器</p>
</li>
<li>
<p>TCP状态转换</p>
</li>
<li>
<p>半关闭、端口复用</p>
</li>
<li>
<p>IO多路复用简介</p>
<ul>
<li>I/O 多路复用<strong>使得程序能同时监听多个文件描述符，能够提高程序的性能</strong>，Linux 下实现 I/O 多路复用的系统调用主要有 select、poll 和 epoll。</li>
</ul>
</li>
<li>
<p>select API介绍</p>
<ul>
<li>
<p>select</p>
<p><strong>select工作过程分析：</strong><img src="https://img.fzhiy.net/img/202204281545651.png" alt="image-20220428154530510"></p>
<blockquote>
<p>主旨思想：</p>
<ol>
<li>首先要构造一个关于文件描述符的列表，将要监听的文件描述符添加到该列表中。</li>
<li>调用一个系统函数（select），监听该列表中的文件描述符，直到这些描述符中的一个或者多个进行I/O操作时，该函数才返回。
a.这个函数是<strong>阻塞</strong>
b.<strong>函数对文件描述符的检测的操作</strong>是由<strong>内核完成</strong>的</li>
<li>在返回时，它会告诉进程有多少（哪些）描述符要进行I/O操作。</li>
</ol>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="c1">// sizeof(fd_set) = 128  1024位
</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;sys/time.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/select.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">select</span><span class="p">(</span><span class="kt">int</span> <span class="n">nfds</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">readfds</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">writefds</span><span class="p">,</span>
            <span class="n">fd_set</span> <span class="o">*</span><span class="n">exceptfds</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">timeout</span><span class="p">);</span>
	<span class="o">-</span> <span class="err">参数：</span>
        <span class="o">-</span> <span class="nl">nfds</span> <span class="p">:</span> <span class="err">委托内核检测的最大文件描述符的值</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="o">-</span> <span class="nl">readfds</span> <span class="p">:</span> <span class="err">要检测的文件描述符的读的集合，委托内核检测哪些文件描述符的读的属性</span>
                <span class="o">-</span> <span class="err">一般检测读操作</span>
                <span class="o">-</span> <span class="err">对应的是对方发送过来的数据，因为读是被动的接收数据，检测的就是读缓冲区</span>
                <span class="o">-</span> <span class="err">是一个传入传出参数</span>
        <span class="o">-</span> <span class="nl">writefds</span> <span class="p">:</span> <span class="err">要检测的文件描述符的写的集合，委托内核检测哪些文件描述符的写的属性</span>
                <span class="o">-</span> <span class="err">委托内核检测写缓冲区是不是还可以写数据（不满的就可以写）</span>
        <span class="o">-</span> <span class="nl">exceptfds</span> <span class="p">:</span> <span class="err">检测发生异常的文件描述符的集合</span>
        <span class="o">-</span> <span class="nl">timeout</span> <span class="p">:</span> <span class="err">设置的超时时间</span>
            <span class="k">struct</span> <span class="n">timeval</span> <span class="p">{</span>
                <span class="kt">long</span> <span class="n">tv_sec</span><span class="p">;</span> <span class="cm">/* seconds */</span>
                <span class="kt">long</span> <span class="n">tv_usec</span><span class="p">;</span> <span class="cm">/* microseconds */</span>
            <span class="p">};</span>
            <span class="o">-</span> <span class="nb">NULL</span> <span class="o">:</span> <span class="err">永久阻塞，直到检测到了文件描述符有变化</span>
            <span class="o">-</span> <span class="n">tv_sec</span> <span class="o">=</span> <span class="mi">0</span> <span class="n">tv_usec</span> <span class="o">=</span> <span class="mi">0</span><span class="err">，</span> <span class="err">不阻塞</span>
            <span class="o">-</span> <span class="n">tv_sec</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="n">tv_usec</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="err">，</span> <span class="err">阻塞对应的时间</span>
    <span class="o">-</span> <span class="err">返回值</span> <span class="o">:</span>
        <span class="o">-</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="err">失败</span>
        <span class="o">-</span> <span class="o">&gt;</span><span class="mi">0</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">:</span> <span class="err">检测的集合中有</span><span class="n">n个文件描述符发生了变化</span>

<span class="c1">// 将参数文件描述符fd对应的标志位设置为0
</span><span class="c1"></span><span class="kt">void</span> <span class="n">FD_CLR</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">set</span><span class="p">);</span>
<span class="c1">// 判断fd对应的标志位是0还是1， 返回值 ： fd对应的标志位的值，0，返回0， 1，返回1
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">FD_ISSET</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">set</span><span class="p">);</span>
<span class="c1">// 将参数文件描述符fd 对应的标志位，设置为1
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">FD_SET</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">set</span><span class="p">);</span>
<span class="c1">// fd_set一共有1024 bit, 全部初始化为0
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">FD_ZERO</span><span class="p">(</span><span class="n">fd_set</span> <span class="o">*</span><span class="n">set</span><span class="p">);</span>			
</code></pre></td></tr></table>
</div>
</div><p>select<strong>缺点</strong>：</p>
<p><img src="https://img.fzhiy.net/img/202204281546939.png" alt="image-20220428154617449"></p>
</li>
</ul>
</li>
<li>
<p>select代码编写</p>
</li>
<li>
<p>poll API介绍以及代码编写</p>
<ul>
<li>
<p>poll</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;poll.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">struct</span> <span class="n">pollfd</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span> <span class="cm">/* 委托内核检测的文件描述符 */</span>
    <span class="kt">short</span> <span class="n">events</span><span class="p">;</span> <span class="cm">/* 委托内核检测文件描述符的什么事件 */</span>
    <span class="kt">short</span> <span class="n">revents</span><span class="p">;</span> <span class="cm">/* 文件描述符实际发生的事件 */</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">pollfd</span> <span class="n">myfd</span><span class="p">;</span>
<span class="n">myfd</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">myfd</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLOUT</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">pollfd</span> <span class="o">*</span><span class="n">fds</span><span class="p">,</span> <span class="n">nfds_t</span> <span class="n">nfds</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">);</span>
<span class="o">-</span> <span class="err">参数：</span>
    <span class="o">-</span> <span class="nl">fds</span> <span class="p">:</span> <span class="err">是一个</span><span class="k">struct</span> <span class="n">pollfd</span> <span class="err">结构体数组，这是一个需要检测的文件描述符的集合</span>
    <span class="o">-</span> <span class="nl">nfds</span> <span class="p">:</span> <span class="err">这个是第一个参数数组中最后一个有效元素的下标</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="o">-</span> <span class="nl">timeout</span> <span class="p">:</span> <span class="err">阻塞时长</span>
            <span class="mi">0</span> <span class="o">:</span> <span class="err">不阻塞</span>
            <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="err">阻塞，当检测到需要检测的文件描述符有变化，解除阻塞</span>
            <span class="o">&gt;</span><span class="mi">0</span> <span class="o">:</span> <span class="err">阻塞的时长</span>
 <span class="o">-</span> <span class="err">返回值：</span>
    <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="err">失败</span>
    <span class="o">&gt;</span><span class="mi">0</span><span class="err">（</span><span class="n">n</span><span class="err">）</span> <span class="o">:</span> <span class="err">成功</span><span class="p">,</span><span class="n">n表示检测到集合中有n个文件描述符发生变化</span>
</code></pre></td></tr></table>
</div>
</div><p><img src="https://img.fzhiy.net/img/202204281517696.png" alt="image-20220428151755532"></p>
</li>
</ul>
</li>
<li>
<p>epoll API介绍</p>
<p><img src="https://img.fzhiy.net/img/202204281544381.png" alt="image-20220428154419741"></p>
<ul>
<li>
<p>epoll</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/epoll.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="c1">// 创建一个新的epoll实例。在内核中创建了一个数据，这个数据中有两个比较重要的数据，一个是需要检测的文件描述符的信息（红黑树），还有一个是就绪列表，存放检测到数据发送改变的文件描述符信息（双向链表）。
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">epoll_create</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">);</span>
<span class="o">-</span> <span class="err">参数：</span>
	<span class="nl">size</span> <span class="p">:</span> <span class="err">目前没有意义了。随便写一个数，必须大于</span><span class="mi">0</span>
<span class="o">-</span> <span class="err">返回值：</span>
    <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="err">失败</span>
    <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">:</span> <span class="err">文件描述符，操作</span><span class="n">epoll实例的</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">epoll_data</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">u32</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">u64</span><span class="p">;</span>
<span class="p">}</span> <span class="n">epoll_data_t</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">epoll_event</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">events</span><span class="p">;</span> <span class="cm">/* Epoll events */</span>
    <span class="n">epoll_data_t</span> <span class="n">data</span><span class="p">;</span> <span class="cm">/* User data variable */</span>
<span class="p">};</span>

<span class="err">常见的</span><span class="n">Epoll检测事件</span><span class="err">：</span>
<span class="o">-</span> <span class="n">EPOLLIN</span>
<span class="o">-</span> <span class="n">EPOLLOUT</span>
<span class="o">-</span> <span class="n">EPOLLERR</span>

<span class="c1">// 对epoll实例进行管理：添加文件描述符信息，删除信息，修改信息
</span><span class="c1"></span><span class="kt">int</span> <span class="n">epoll_ctl</span><span class="p">(</span><span class="kt">int</span> <span class="n">epfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">op</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epoll_event</span> <span class="o">*</span><span class="n">event</span><span class="p">);</span>
<span class="o">-</span> <span class="err">参数：</span>
    <span class="o">-</span> <span class="nl">epfd</span> <span class="p">:</span> <span class="n">epoll实例对应的文件描述符</span>
    <span class="o">-</span> <span class="nl">op</span> <span class="p">:</span> <span class="err">要进行什么操作</span>
        <span class="nl">EPOLL_CTL_ADD</span><span class="p">:</span> <span class="err">添加</span>
        <span class="nl">EPOLL_CTL_MOD</span><span class="p">:</span> <span class="err">修改</span>
        <span class="nl">EPOLL_CTL_DEL</span><span class="p">:</span> <span class="err">删除</span>
    <span class="o">-</span> <span class="nl">fd</span> <span class="p">:</span> <span class="err">要检测的文件描述符</span>
    <span class="o">-</span> <span class="nl">event</span> <span class="p">:</span> <span class="err">检测文件描述符什么事情</span>

<span class="c1">// 检测函数
</span><span class="c1"></span><span class="kt">int</span> <span class="n">epoll_wait</span><span class="p">(</span><span class="kt">int</span> <span class="n">epfd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epoll_event</span> <span class="o">*</span><span class="n">events</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxevents</span><span class="p">,</span> <span class="kt">int</span>
<span class="n">timeout</span><span class="p">);</span>
<span class="o">-</span> <span class="err">参数：</span>
    <span class="o">-</span> <span class="nl">epfd</span> <span class="p">:</span> <span class="n">epoll实例对应的文件描述符</span>
    <span class="o">-</span> <span class="nl">events</span> <span class="p">:</span> <span class="err">传出参数，保存了发送了变化的文件描述符的信息</span>
    <span class="o">-</span> <span class="nl">maxevents</span> <span class="p">:</span> <span class="err">第二个参数结构体数组的大小</span>
    <span class="o">-</span> <span class="nl">timeout</span> <span class="p">:</span> <span class="err">阻塞时间</span>
        <span class="o">-</span> <span class="mi">0</span> <span class="o">:</span> <span class="err">不阻塞</span>
        <span class="o">-</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="err">阻塞，直到检测到</span><span class="n">fd数据发生变化</span><span class="err">，解除阻塞</span>
        <span class="o">-</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">:</span> <span class="err">阻塞的时长（毫秒）</span>
<span class="o">-</span> <span class="err">返回值：</span>
    <span class="o">-</span> <span class="err">成功，返回发送变化的文件描述符的个数</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="o">-</span> <span class="err">失败</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>
<p>epoll代码编写</p>
</li>
<li>
<p>epoll的两种工作模式</p>
<ul>
<li>
<p><strong>LT 模式 （水平触发）</strong></p>
<p>假设委托内核检测读事件 -&gt; 检测fd的读缓冲区
读缓冲区有数据 - &gt; epoll检测到了会给用户通知
a.用户不读数据，数据一直在缓冲区，epoll 会一直通知
b.用户只读了一部分数据，epoll会通知
c.缓冲区的数据读完了，不通知</p>
<blockquote>
<p>LT（level - triggered）是<strong>缺省的工作方式</strong>，并且<strong>同时支持 block 和 no-block socket</strong>。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操作。如果你不作任何操作，内核还是会继续通知你的。</p>
</blockquote>
</li>
<li>
<p><strong>ET 模式（边沿触发）</strong></p>
<p>假设委托内核检测读事件 -&gt; 检测fd的读缓冲区
读缓冲区有数据 - &gt; epoll检测到了会给用户通知
a.用户不读数据，数据一致在缓冲区中，epoll下次检测的时候就不通知了
b.用户只读了一部分数据，epoll不通知
c.缓冲区的数据读完了，不通知</p>
<blockquote>
<p>ET（edge - triggered）是高速工作方式，<strong>只支持 no-block socket</strong>。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了。但是请注意，如果一直不对这个 fd 作 IO 操作（从而导致它再次变成未就绪），内核不会发送更多的通知（only once）。ET 模式<strong>在很大程度上减少了 epoll 事件被重复触发的次数</strong>，因此效率要比 LT 模式高。epoll工作在 ET 模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>UDP通信实现</p>
</li>
<li>
<p>广播</p>
</li>
<li>
<p>组播</p>
</li>
<li>
<p>本地套接字通信</p>
</li>
</ul>
<h2 id="5项目实战与总结">5.项目实战与总结</h2>
<ul>
<li>阻塞和非阻塞、同步和异步</li>
<li>Unix、Linux上的五种IO模型</li>
<li>Web服务器简介以及HTTP协议</li>
<li>服务器编程基本框架和两种高效的事件处理模式</li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>牛客网——C++高薪面试项目 <a href="https://www.nowcoder.com/study/live/504">https://www.nowcoder.com/study/live/504</a></li>
</ul>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">fzhiy</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2022-04-20
        
    </span>
  </p>
  
  
</div>
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">赞赏支持</label>
  <div class="qr-code">
    
    <label class="qr-code-image" for="reward">
        <img class="image" src="https://img.fzhiy.net/img/20200812154839.png">
        <span>微信打赏</span>
      </label>
    <label class="qr-code-image" for="reward">
        <img class="image" src="https://img.fzhiy.net/img/20200812154858.png">
        <span>支付宝打赏</span>
      </label>
  </div>
</div><footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/linux/">Linux</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E7%AC%94%E8%AF%95%E8%85%BE%E8%AE%AF2022%E6%8A%80%E6%9C%AF%E5%90%8E%E7%AB%AF%E5%AE%9E%E4%B9%A0%E7%AC%94%E8%AF%95%E9%A2%98/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">[笔试]腾讯2022技术后端实习笔试题</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/2022-04-13-c&#43;&#43;effective-c&#43;&#43;%E7%AC%94%E8%AE%B0/">
            <span class="next-text nav-default">[C&#43;&#43;]Effective C&#43;&#43;笔记</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="fzhiy/blog"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:fzhiy270@163.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/fzhiy" class="iconfont icon-github" title="github"></a>
      <a href="https://blog.csdn.net/feng_zhiyu" class="iconfont icon-csdn" title="csdn"></a>
      <a href="https://www.zhihu.com/people/ni-feng-88-10" class="iconfont icon-zhihu" title="zhihu"></a>
  <a href="https://blog.fzhiy.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> 本站总访问量 <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次 </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> 本站总访客数 <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 人 </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2020 - 
    2023<span class="heart"><i class="iconfont icon-heart"></i></span><span>fzhiy</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>

<script id="baidu_analytics">
  var _hmt = _hmt || [];
  (function() {
    if (window.location.hostname === 'localhost') return;
    var hm = document.createElement("script"); hm.async = true;
    hm.src = "https://hm.baidu.com/hm.js?e4ff802fe8f2731918ababdb4ccf87bc";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>

<script id="baidu_push">
  (function(){
    if (window.location.hostname === 'localhost') return;
    var bp = document.createElement('script'); bp.async = true;
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
      bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
  })();
</script>




</body>
</html>

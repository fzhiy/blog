---
title: "[C++]内存管理"
date: 2021-06-27T20:47:09+08:00
draft: false

toc: true
categories: [Notes]
tags: [Cpp]
keywords: []
description: ""
---


- C++应用程序实用memory的途径

  ![image-20210626160209890](https://img.fzhiy.net/img/image-20210626160209890.png)

- C++ memory primitives

  ![image-20210626155952846](https://img.fzhiy.net/img/image-20210626155952846.png)

  ![image-20210626160017978](https://img.fzhiy.net/img/image-20210626160017978.png)

- new expression

  ![image-20210626155629132](https://img.fzhiy.net/img/image-20210626155629132.png)

  上图中，只有编译器才能调用构造函数（**否则报错，示例如下图**）。 不能由App.调用构造函数， **可用placement new**调用

  ![image-20210626155835196](https://img.fzhiy.net/img/image-20210626155835196.png)

- delete expression

  先调用析构函数，然后释放内存

  ![image-20210626155759951](https://img.fzhiy.net/img/image-20210626155759951.png)

- ==placement new== （具体指 **new(p)** 或 **::operator new(size, void*)** ）

  - 允许将object 构造在allocated memory中。没有所谓的 placement delete，因为**placement new根本没分配memory** 或  <u>与placement new 对应</u>的operator delete为 placement delete 

    ![image-20210626154821433](https://img.fzhiy.net/img/image-20210626154821433.png)

  - 等同于调用 构造函数，因为下图的第一步实际上没有做事

    ![image-20210626155000625](https://img.fzhiy.net/img/image-20210626155000625.png)

- 重载(overload)

  后面将路线2转为路线1即 为重载 

  ![image-20210626155534404](https://img.fzhiy.net/img/image-20210626155534404.png)

  C++容器分配内存的途径

  ![image-20210626160923954](https://img.fzhiy.net/img/image-20210626160923954.png)

  - 重载 ::operator new/ ::operator delete

    ![image-20210626161428120](https://img.fzhiy.net/img/image-20210626161428120.png)

  - 重载operator new/operator delete

    ![image-20210626161529258](https://img.fzhiy.net/img/image-20210626161529258.png)

  - 重载operator new[]/operator delete[]

    ![image-20210626161748505](https://img.fzhiy.net/img/image-20210626161748505.png)

  - 示例

    ![image-20210626162423597](https://img.fzhiy.net/img/image-20210626162423597.png)

    ![image-20210626162443597](https://img.fzhiy.net/img/image-20210626162443597.png)

    ![image-20210626162458469](https://img.fzhiy.net/img/image-20210626162458469.png)

    **<u>不同的写法：::delete 这样等同于 global scope operator ::， 会绕过前述所有overload functions，强迫使用global version</u>**

  - 重载new() / delete()

    **参数不同， 第一个参数必须是size_t ，其余参数以new所指定的placement arguments为初值**

    ![image-20210626162932369](https://img.fzhiy.net/img/image-20210626162932369.png)

    重载示例：

    ![image-20210626163144651](https://img.fzhiy.net/img/image-20210626163144651.png)

    ![image-20210626163314990](https://img.fzhiy.net/img/image-20210626163314990.png)

    operator delete 用来处理构造过程异常时调用的，因此 其与operator new(...)不一一对应也不会出现任何错误

    basic string 即为  string，使用typedef后的

  ![image-20210626164205560](https://img.fzhiy.net/img/image-20210626164205560.png)

- pre-class allocator

  - Case 1

  内存池的一个例子

  ![image-20210626165000900](https://img.fzhiy.net/img/image-20210626165000900.png)

  ![image-20210626165137977](https://img.fzhiy.net/img/image-20210626165137977.png)

  右边的结果是因为 类中没写 operator new/delete，默认内存中会**带有cookie（上下都有四个字节，一共8个字节）**

  - Case 2

    **union的使用， 将AirplaneRep看作一个指针**

  ![image-20210626165653042](https://img.fzhiy.net/img/image-20210626165653042.png)

  ![image-20210626193845237](https://img.fzhiy.net/img/image-20210626193845237.png)

  - 

- 

  

